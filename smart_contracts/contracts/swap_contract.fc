#include "imports/stdlib.fc"; ;; Include the standard library

;; Declare the global fee_percent variable
global int fee_percent;

() set_fee() {
    ;; Assign a value to the global variable
    fee_percent = 10;
}

slice get_platform_wallet_address() method_id {
    ;; Manually create the address slice
    return begin_parse(begin_cell()
        .store_uint(0, 8) ;; Workchain ID
        ;; Manually store the 256-bit address (replace with your actual address bytes)
        .store_uint(D93F8F12E0F53F9091D1727E76BAE1D08A81FA06DE10BA1B9AC3, 256)
        .end_cell());
}

() recv_internal(int msg_value, cell in_msg, slice in_msg_body) impure {
    ;; Set the fee percentage (initialize the global variable)
    set_fee();

    ;; Decode the incoming message body to extract swap details
    int swap_amount = in_msg_body~load_int(257); ;; Amount being swapped

    ;; Calculate the fee based on the percentage
    int fee = (swap_amount * fee_percent) / 1000;
    int amount_after_fee = swap_amount - fee;

    ;; Load the platform wallet address using the function
    slice platform_wallet_address = get_platform_wallet_address();

    ;; Send the fee to the platform wallet
    var fee_message = begin_cell()
        .store_uint(0, 32) ;; Operation ID (optional)
        .store_uint(0, 64) ;; Query ID (optional)
        .end_cell();

    send_raw_message(begin_cell().store_slice(platform_wallet_address).end_cell(), fee);

    ;; Load the destination address from the message body
    slice destination_address;
    (destination_address, ) = in_msg_body~load_msg_addr();

    ;; Forward the remaining amount to the destination address
    var forward_message = begin_cell()
        .store_uint(0, 32) ;; Operation ID (optional)
        .store_uint(0, 64) ;; Query ID (optional)
        .end_cell();

    send_raw_message(begin_cell().store_slice(destination_address).end_cell(), amount_after_fee);
}
