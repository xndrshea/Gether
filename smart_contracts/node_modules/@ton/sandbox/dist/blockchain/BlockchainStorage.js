"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RemoteBlockchainStorage = exports.wrapTonClient4ForRemote = exports.LocalBlockchainStorage = void 0;
const core_1 = require("@ton/core");
const SmartContract_1 = require("./SmartContract");
class LocalBlockchainStorage {
    constructor() {
        this.contracts = new Map();
    }
    async getContract(blockchain, address) {
        let existing = this.contracts.get(address.toString());
        if (!existing) {
            existing = SmartContract_1.SmartContract.empty(blockchain, address);
            this.contracts.set(address.toString(), existing);
        }
        return existing;
    }
    knownContracts() {
        return Array.from(this.contracts.values());
    }
    clearKnownContracts() {
        this.contracts.clear();
    }
}
exports.LocalBlockchainStorage = LocalBlockchainStorage;
function convertTonClient4State(state) {
    switch (state.type) {
        case 'uninit':
            return { type: 'uninit' };
        case 'active':
            return { type: 'active', state: { code: state.code === null ? undefined : core_1.Cell.fromBase64(state.code), data: state.data === null ? undefined : core_1.Cell.fromBase64(state.data) } };
        case 'frozen':
            return { type: 'frozen', stateHash: BigInt('0x' + Buffer.from(state.stateHash, 'base64').toString('hex')) };
        default:
            throw new Error(`Unknown type ${state}`);
    }
}
/**
 * Wraps ton client for remote storage.
 *
 * ```ts
 * let client = new TonClient4({
 *     endpoint: 'https://mainnet-v4.tonhubapi.com'
 * })
 *
 * let remoteStorageClient = wrapTonClient4ForRemote(client);
 * ```
 *
 * @param client TonClient4 to wrap
 */
function wrapTonClient4ForRemote(client) {
    return {
        getLastBlockSeqno: async () => {
            const last = await client.getLastBlock();
            return last.last.seqno;
        },
        getAccount: async (seqno, address) => {
            const { account } = await client.getAccount(seqno, address);
            return {
                state: convertTonClient4State(account.state),
                balance: BigInt(account.balance.coins),
                lastTransaction: account.last === null ? undefined : {
                    lt: BigInt(account.last.lt),
                    hash: Buffer.from(account.last.hash, 'base64'),
                },
            };
        },
    };
}
exports.wrapTonClient4ForRemote = wrapTonClient4ForRemote;
/**
 * @class {RemoteBlockchainStorage} Remote blockchain storage implementation.
 * ```ts
 * let client = new TonClient4({
 *     endpoint: 'https://mainnet-v4.tonhubapi.com'
 * })
 *
 * let blockchain = await Blockchain.create({
 *     storage: new RemoteBlockchainStorage(wrapTonClient4ForRemote(client), 34892000)
 * });
 * ```
 */
class RemoteBlockchainStorage {
    constructor(client, blockSeqno) {
        this.contracts = new Map();
        this.client = client;
        this.blockSeqno = blockSeqno;
    }
    async getLastBlockSeqno() {
        return this.blockSeqno ?? await this.client.getLastBlockSeqno();
    }
    async getContract(blockchain, address) {
        let existing = this.contracts.get(address.toString());
        if (!existing) {
            let blockSeqno = await this.getLastBlockSeqno();
            let account = await this.client.getAccount(blockSeqno, address);
            const lt = account.lastTransaction?.lt ?? 0n;
            existing = new SmartContract_1.SmartContract({
                lastTransactionHash: BigInt('0x' + (account.lastTransaction?.hash?.toString('hex') ?? '0')),
                lastTransactionLt: lt,
                account: {
                    addr: address,
                    storageStats: {
                        used: {
                            cells: 0n,
                            bits: 0n,
                            publicCells: 0n,
                        },
                        lastPaid: 0,
                        duePayment: null,
                    },
                    storage: {
                        lastTransLt: lt === 0n ? 0n : (lt + 1n),
                        balance: { coins: account.balance },
                        state: account.state,
                    },
                },
            }, blockchain);
            this.contracts.set(address.toString(), existing);
        }
        return existing;
    }
    knownContracts() {
        return Array.from(this.contracts.values());
    }
    clearKnownContracts() {
        this.contracts.clear();
    }
}
exports.RemoteBlockchainStorage = RemoteBlockchainStorage;
