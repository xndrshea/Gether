"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.verify = void 0;
const core_1 = require("@ton/core");
const compile_1 = require("../compile/compile");
const path_1 = __importDefault(require("path"));
const createNetworkProvider_1 = require("../network/createNetworkProvider");
const build_1 = require("./build");
const utils_1 = require("../utils");
const arg_1 = __importDefault(require("arg"));
const constants_1 = require("./constants");
const backends = {
    mainnet: {
        sourceRegistry: core_1.Address.parse('EQD-BJSVUJviud_Qv7Ymfd3qzXdrmV525e3YDzWQoHIAiInL'),
        backends: [
            'https://ton-source-prod-1.herokuapp.com',
            'https://ton-source-prod-2.herokuapp.com',
            'https://ton-source-prod-3.herokuapp.com',
        ],
        id: 'orbs.com',
    },
    testnet: {
        sourceRegistry: core_1.Address.parse('EQCsdKYwUaXkgJkz2l0ol6qT_WxeRbE_wBCwnEybmR0u5TO8'),
        backends: ['https://ton-source-prod-testnet-1.herokuapp.com'],
        id: 'orbs-testnet',
    },
};
function removeRandom(els) {
    return els.splice(Math.floor(Math.random() * els.length), 1)[0];
}
class VerifierRegistry {
    constructor(address) {
        this.address = address;
    }
    async getVerifiers(provider) {
        const res = await provider.get('get_verifiers', []);
        const item = res.stack.readCell();
        const c = item.beginParse();
        const d = c.loadDict(core_1.Dictionary.Keys.BigUint(256), {
            serialize: () => {
                throw undefined;
            },
            parse: (s) => s,
        });
        return Array.from(d.values()).map((v) => {
            const admin = v.loadAddress();
            const quorom = v.loadUint(8);
            const pubKeyEndpoints = v.loadDict(core_1.Dictionary.Keys.BigUint(256), core_1.Dictionary.Values.Uint(32));
            return {
                admin: admin,
                quorum: quorom,
                pubKeyEndpoints: new Map(Array.from(pubKeyEndpoints).map(([k, v]) => [k, v])),
                name: v.loadRef().beginParse().loadStringTail(),
                url: v.loadRef().beginParse().loadStringTail(),
            };
        });
    }
}
class SourceRegistry {
    constructor(address) {
        this.address = address;
    }
    async getVerifierRegistry(provider) {
        const { stack } = await provider.get('get_verifier_registry_address', []);
        return stack.readAddress();
    }
}
async function lookupCodeHash(hash, ui, retryCount = 5) {
    let queryResponse;
    let foundAddr;
    let done = false;
    const graphqlUrl = 'https://dton.io/graphql/';
    const query = `{
        account_states(page:0, page_size:1, account_state_state_init_code_hash: "${hash.toString('hex').toUpperCase()}")
        {
            address
            workchain
        }
    }`;
    do {
        try {
            ui.write('Checking if such a contract is already deployed...');
            const resp = await fetch(graphqlUrl, {
                method: 'POST',
                body: JSON.stringify({ query }),
                headers: { 'Content-Type': 'application/json' },
            });
            if (resp.ok) {
                queryResponse = await resp.json();
                const states = queryResponse.data.account_states;
                if (states.length > 0) {
                    const state = states[0];
                    foundAddr = core_1.Address.parseRaw(`${state.workchain}:${state.address}`).toString();
                }
                else {
                    ui.write('No such contract was found!');
                }
                done = true;
            }
            else {
                retryCount--;
            }
            // Meh
        }
        catch (e) {
            retryCount--;
            if (e.cause) {
                if (e.cause.code == 'ETIMEDOUT') {
                    ui.write('API timed out, waiting...');
                    await (0, utils_1.sleep)(5000);
                }
            }
            else {
                ui.write(e);
            }
        }
    } while (!done && retryCount > 0);
    return foundAddr;
}
const verify = async (args, ui, context) => {
    const localArgs = (0, arg_1.default)({ ...createNetworkProvider_1.argSpec, ...constants_1.helpArgs });
    if (localArgs['--help']) {
        ui.write(constants_1.helpMessages['verify']);
        return;
    }
    const sel = await (0, build_1.selectCompile)(ui, localArgs);
    const networkProvider = await (0, createNetworkProvider_1.createNetworkProvider)(ui, localArgs, context.config, false);
    const sender = networkProvider.sender();
    const senderAddress = sender.address;
    if (senderAddress === undefined) {
        throw new Error('Sender address needs to be known');
    }
    const network = networkProvider.network();
    if (network === 'custom') {
        throw new Error('Cannot use custom network');
    }
    const result = await (0, compile_1.doCompile)(sel.name);
    const resHash = result.code.hash();
    ui.write(`Compiled code hash hex: ${resHash.toString('hex')}`);
    ui.write('We can look up the address with such code hash in the blockchain automatically');
    const passManually = await ui.prompt('Do you want to specify the address manually?');
    let addr;
    if (passManually) {
        addr = (await ui.inputAddress('Deployed contract address')).toString();
    }
    else {
        const alreadyDeployed = await lookupCodeHash(resHash, ui);
        if (alreadyDeployed) {
            ui.write(`Contract is already deployed at: ${alreadyDeployed}\nUsing that address.`);
            ui.write(`https://tonscan.org/address/${alreadyDeployed}`);
            addr = alreadyDeployed;
        }
        else {
            ui.write("Please enter the contract's address manually");
            addr = (await ui.inputAddress('Deployed contract address')).toString();
        }
    }
    let src;
    const fd = new FormData();
    if (result.lang === 'func') {
        for (const f of result.snapshot) {
            fd.append(f.filename, new Blob([f.content]), path_1.default.basename(f.filename));
        }
        src = {
            compiler: 'func',
            compilerSettings: {
                funcVersion: result.version,
                commandLine: '-SPA ' + result.targets.join(' '),
            },
            knownContractAddress: addr,
            knownContractHash: result.code.hash().toString('base64'),
            sources: result.snapshot.map((s) => ({
                includeInCommand: result.targets.includes(s.filename),
                isEntrypoint: result.targets.includes(s.filename),
                isStdLib: false,
                hasIncludeDirectives: true,
                folder: path_1.default.dirname(s.filename),
            })),
            senderAddress: senderAddress.toString(),
        };
    }
    else if (result.lang === 'tact') {
        let pkg = undefined;
        for (const [k, v] of result.fs) {
            if (k.endsWith('.pkg')) {
                pkg = {
                    name: k,
                    content: v,
                };
                break;
            }
        }
        if (pkg === undefined) {
            throw new Error('Could not find .pkg in compilation results');
        }
        fd.append(path_1.default.basename(pkg.name), new Blob([pkg.content]), path_1.default.basename(pkg.name));
        src = {
            compiler: 'tact',
            compilerSettings: {
                tactVersion: '',
            },
            knownContractAddress: addr,
            knownContractHash: result.code.hash().toString('base64'),
            sources: [
                {
                    includeInCommand: true,
                    isEntrypoint: false,
                    isStdLib: false,
                    hasIncludeDirectives: false,
                    folder: '',
                },
            ],
            senderAddress: senderAddress.toString(),
        };
    }
    else {
        // future proofing
        throw new Error('Unsupported language ' + result.lang);
    }
    fd.append('json', new Blob([JSON.stringify(src)], {
        type: 'application/json',
    }), 'blob');
    const backend = backends[network];
    const sourceRegistry = networkProvider.open(new SourceRegistry(backend.sourceRegistry));
    const verifierRegistry = networkProvider.open(new VerifierRegistry(await sourceRegistry.getVerifierRegistry()));
    const verifier = (await verifierRegistry.getVerifiers()).find((v) => v.name === backend.id);
    if (verifier === undefined) {
        throw new Error('Could not find verifier');
    }
    const remainingBackends = [...backend.backends];
    const sourceResponse = await fetch(removeRandom(remainingBackends) + '/source', {
        method: 'POST',
        body: fd,
    });
    if (sourceResponse.status !== 200) {
        throw new Error('Could not compile on backend:\n' + (await sourceResponse.json()));
    }
    const sourceResult = await sourceResponse.json();
    if (sourceResult.compileResult.result !== 'similar') {
        throw new Error(sourceResult.compileResult.error);
    }
    let msgCell = sourceResult.msgCell;
    let acquiredSigs = 1;
    while (acquiredSigs < verifier.quorum) {
        const curBackend = removeRandom(remainingBackends);
        ui.write(`Using backend: ${curBackend}`);
        const signResponse = await fetch(curBackend + '/sign', {
            method: 'POST',
            body: JSON.stringify({
                messageCell: msgCell,
            }),
            headers: { 'Content-Type': 'application/json' },
        });
        if (signResponse.status !== 200) {
            throw new Error('Could not sign on backend:\n' + (await signResponse.text()));
        }
        const signResult = await signResponse.json();
        msgCell = signResult.msgCell;
        acquiredSigs++;
    }
    const c = core_1.Cell.fromBoc(Buffer.from(msgCell.data))[0];
    await networkProvider.sender().send({
        to: verifierRegistry.address,
        value: (0, core_1.toNano)('0.5'),
        body: c,
    });
    ui.write(`Contract successfully verified at https://verifier.ton.org/${addr}`);
};
exports.verify = verify;
