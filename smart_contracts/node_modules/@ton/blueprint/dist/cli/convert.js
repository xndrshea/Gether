"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.convert = void 0;
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const arg_1 = __importDefault(require("arg"));
const createNetworkProvider_1 = require("../network/createNetworkProvider");
const template_1 = require("../template");
const paths_1 = require("../paths");
const constants_1 = require("./constants");
function createWrapperName(old) {
    return old
        .split(/[-_]/)
        .map((x) => x.replace(x[0], x[0].toUpperCase()))
        .join('');
}
function quoteString(str) {
    const quote = "'";
    const quoted = str.startsWith(quote) && str.endsWith(quote);
    return quoted ? str : quote + str + quote;
}
function findFile(dir, filename) {
    const contents = (0, fs_1.readdirSync)(dir);
    let hasFile = contents.includes(filename);
    let foundPath = '';
    if (hasFile) {
        foundPath = path_1.default.join(dir, filename);
        if ((0, fs_1.statSync)(foundPath).isFile()) {
            return foundPath;
        }
    }
    for (let entry of contents) {
        const entryPath = path_1.default.join(dir, entry);
        const stat = (0, fs_1.statSync)(entryPath);
        if (stat.isDirectory()) {
            foundPath = findFile(entryPath, filename);
            if (foundPath !== '') {
                break;
            }
        }
    }
    return foundPath;
}
function parseCompileString(str, src_dir, ui) {
    // Naive but does the job
    const tokens = str.split(/\\?\s+/).filter((t) => t != '\\');
    const outputIdx = tokens.indexOf('-o');
    if (outputIdx < 0) {
        throw new Error('No output flag (-o) found in command:' + str);
    }
    const outFile = tokens[outputIdx + 1];
    const outputName = outFile.match(/([A-Za-z0-9\-_\\\/]*)/);
    if (outputName === null) {
        throw new Error(`Something went wrong when parsing output from ${outFile}`);
    }
    const wrapperName = createWrapperName(path_1.default.basename(outputName[1]));
    const sourceFiles = tokens.filter((x) => x.match(/\.func|\.fc['"]?$/) !== null).map((t) => t.replace(/['"`]/g, ''));
    if (sourceFiles.length === 0) {
        throw new Error(`No source files found in command:${str}`);
    }
    for (let i = 0; i < sourceFiles.length; i++) {
        const testPath = path_1.default.join(src_dir, sourceFiles[i]);
        if ((0, fs_1.existsSync)(testPath)) {
            sourceFiles[i] = quoteString(testPath);
        }
        else {
            const foundPath = findFile(src_dir, sourceFiles[i]);
            if (foundPath === '') {
                throw new Error(`${sourceFiles[i]} is not found anywhere`);
            }
            src_dir = path_1.default.dirname(foundPath);
            sourceFiles[i] = quoteString(foundPath);
        }
    }
    return {
        name: wrapperName,
        targets: sourceFiles.join(','),
    };
}
const convert = async (args, ui) => {
    const localArgs = (0, arg_1.default)({ ...createNetworkProvider_1.argSpec, ...constants_1.helpArgs });
    if (localArgs['--help']) {
        ui.write(constants_1.helpMessages['convert']);
        return;
    }
    let filePath;
    if (localArgs._.length < 2) {
        filePath = await ui.input('Please specify path to convert from:');
    }
    else {
        filePath = localArgs._[1];
    }
    const content = (0, fs_1.readFileSync)(filePath, { encoding: 'utf-8' });
    const srcDir = path_1.default.dirname(filePath);
    const compileStrings = content.replace(/\\[\r?\n]+/g, '').matchAll(/\s?func\s+(.*)\n/g);
    if (compileStrings === null) {
        throw new Error(`No func related commands found in ${filePath}`);
    }
    const templatePath = path_1.default.join(template_1.TEMPLATES_DIR, 'func', 'legacy', 'wrappers', 'compile.ts.template');
    const templateContent = (0, fs_1.readFileSync)(templatePath, { encoding: 'utf-8' });
    if (!(0, fs_1.existsSync)(paths_1.WRAPPERS_DIR)) {
        ui.write('Creating wrappers directory...');
        (0, fs_1.mkdirSync)(paths_1.WRAPPERS_DIR);
    }
    for (let compileStr of compileStrings) {
        let parsed;
        try {
            parsed = parseCompileString(compileStr[1], srcDir, ui);
        }
        catch (e) {
            ui.write(e.toString());
            continue;
        }
        const resTemplate = (0, template_1.executeTemplate)(templateContent, parsed);
        let lineIdx = resTemplate.indexOf('\n');
        const contentIdx = lineIdx + 1;
        if (resTemplate[lineIdx - 1] === '\r') {
            lineIdx--;
        }
        const wrapperName = resTemplate.substring(0, lineIdx);
        const fileName = path_1.default.join(paths_1.WRAPPERS_DIR, wrapperName);
        const content = resTemplate.substring(contentIdx);
        if ((0, fs_1.existsSync)(fileName)) {
            ui.write(`File ${wrapperName} already exists!`);
            const overwrite = await ui.prompt('Do you want to overwrite it?');
            if (!overwrite) {
                ui.write(`Skipping ${wrapperName}`);
                continue;
            }
        }
        (0, fs_1.writeFileSync)(fileName, content, { encoding: 'utf-8' });
        ui.write(`${wrapperName} wrapper created!`);
    }
};
exports.convert = convert;
