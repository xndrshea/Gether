"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _SendProviderSender_provider, _WrappedContractProvider_address, _WrappedContractProvider_provider, _WrappedContractProvider_init, _WrappedContractProvider_factory, _NetworkProviderImpl_tc, _NetworkProviderImpl_sender, _NetworkProviderImpl_network, _NetworkProviderImpl_explorer, _NetworkProviderImpl_ui;
Object.defineProperty(exports, "__esModule", { value: true });
exports.createNetworkProvider = exports.argSpec = void 0;
const utils_1 = require("../utils");
const DeeplinkProvider_1 = require("./send/DeeplinkProvider");
const TonConnectProvider_1 = require("./send/TonConnectProvider");
const TonHubProvider_1 = require("./send/TonHubProvider");
const core_1 = require("@ton/core");
const ton_1 = require("@ton/ton");
const ton_access_1 = require("@orbs-network/ton-access");
const FSStorage_1 = require("./storage/FSStorage");
const path_1 = __importDefault(require("path"));
const paths_1 = require("../paths");
const crypto_1 = require("@ton/crypto");
const MnemonicProvider_1 = require("./send/MnemonicProvider");
exports.argSpec = {
    '--mainnet': Boolean,
    '--testnet': Boolean,
    '--custom': String,
    '--custom-type': String,
    '--custom-version': String,
    '--custom-key': String,
    '--tonconnect': Boolean,
    '--deeplink': Boolean,
    '--tonhub': Boolean,
    '--mnemonic': Boolean,
    '--tonscan': Boolean,
    '--tonviewer': Boolean,
    '--toncx': Boolean,
    '--dton': Boolean,
};
class SendProviderSender {
    constructor(provider) {
        _SendProviderSender_provider.set(this, void 0);
        __classPrivateFieldSet(this, _SendProviderSender_provider, provider, "f");
        this.address = provider.address();
    }
    async send(args) {
        if (args.bounce !== undefined) {
            console.warn("Warning: blueprint's Sender does not support `bounce` flag, because it is ignored by all used Sender APIs");
            console.warn('To silence this warning, change your `bounce` flags passed to Senders to unset or undefined');
        }
        if (!(args.sendMode === undefined || args.sendMode === core_1.SendMode.PAY_GAS_SEPARATELY)) {
            throw new Error('Deployer sender does not support `sendMode` other than `PAY_GAS_SEPARATELY`');
        }
        await __classPrivateFieldGet(this, _SendProviderSender_provider, "f").sendTransaction(args.to, args.value, args.body ?? undefined, args.init ?? undefined);
    }
}
_SendProviderSender_provider = new WeakMap();
class WrappedContractProvider {
    constructor(address, factory, init) {
        _WrappedContractProvider_address.set(this, void 0);
        _WrappedContractProvider_provider.set(this, void 0);
        _WrappedContractProvider_init.set(this, void 0);
        _WrappedContractProvider_factory.set(this, void 0);
        __classPrivateFieldSet(this, _WrappedContractProvider_address, address, "f");
        __classPrivateFieldSet(this, _WrappedContractProvider_provider, factory({ address, init }), "f");
        __classPrivateFieldSet(this, _WrappedContractProvider_init, init, "f");
        __classPrivateFieldSet(this, _WrappedContractProvider_factory, factory, "f");
    }
    async getState() {
        return await __classPrivateFieldGet(this, _WrappedContractProvider_provider, "f").getState();
    }
    async get(name, args) {
        return await __classPrivateFieldGet(this, _WrappedContractProvider_provider, "f").get(name, args);
    }
    async external(message) {
        return await __classPrivateFieldGet(this, _WrappedContractProvider_provider, "f").external(message);
    }
    async internal(via, args) {
        const init = __classPrivateFieldGet(this, _WrappedContractProvider_init, "f") && (await this.getState()).state.type !== 'active' ? __classPrivateFieldGet(this, _WrappedContractProvider_init, "f") : undefined;
        return await via.send({
            to: __classPrivateFieldGet(this, _WrappedContractProvider_address, "f"),
            value: typeof args.value === 'string' ? (0, core_1.toNano)(args.value) : args.value,
            sendMode: args.sendMode,
            bounce: args.bounce,
            init,
            body: typeof args.body === 'string' ? (0, core_1.comment)(args.body) : args.body,
        });
    }
    open(contract) {
        return (0, core_1.openContract)(contract, (params) => new WrappedContractProvider(params.address, __classPrivateFieldGet(this, _WrappedContractProvider_factory, "f"), params.init));
    }
    getTransactions(address, lt, hash, limit) {
        return __classPrivateFieldGet(this, _WrappedContractProvider_provider, "f").getTransactions(address, lt, hash, limit);
    }
}
_WrappedContractProvider_address = new WeakMap(), _WrappedContractProvider_provider = new WeakMap(), _WrappedContractProvider_init = new WeakMap(), _WrappedContractProvider_factory = new WeakMap();
class NetworkProviderImpl {
    constructor(tc, sender, network, explorer, ui) {
        _NetworkProviderImpl_tc.set(this, void 0);
        _NetworkProviderImpl_sender.set(this, void 0);
        _NetworkProviderImpl_network.set(this, void 0);
        _NetworkProviderImpl_explorer.set(this, void 0);
        _NetworkProviderImpl_ui.set(this, void 0);
        __classPrivateFieldSet(this, _NetworkProviderImpl_tc, tc, "f");
        __classPrivateFieldSet(this, _NetworkProviderImpl_sender, sender, "f");
        __classPrivateFieldSet(this, _NetworkProviderImpl_network, network, "f");
        __classPrivateFieldSet(this, _NetworkProviderImpl_explorer, explorer, "f");
        __classPrivateFieldSet(this, _NetworkProviderImpl_ui, ui, "f");
    }
    network() {
        return __classPrivateFieldGet(this, _NetworkProviderImpl_network, "f");
    }
    explorer() {
        return __classPrivateFieldGet(this, _NetworkProviderImpl_explorer, "f");
    }
    sender() {
        return __classPrivateFieldGet(this, _NetworkProviderImpl_sender, "f");
    }
    api() {
        return __classPrivateFieldGet(this, _NetworkProviderImpl_tc, "f");
    }
    provider(address, init) {
        const factory = (params) => __classPrivateFieldGet(this, _NetworkProviderImpl_tc, "f").provider(params.address, params.init);
        return new WrappedContractProvider(address, factory, init);
    }
    async isContractDeployed(address) {
        if (__classPrivateFieldGet(this, _NetworkProviderImpl_tc, "f") instanceof ton_1.TonClient4) {
            return __classPrivateFieldGet(this, _NetworkProviderImpl_tc, "f").isContractDeployed((await __classPrivateFieldGet(this, _NetworkProviderImpl_tc, "f").getLastBlock()).last.seqno, address);
        }
        else {
            return (await __classPrivateFieldGet(this, _NetworkProviderImpl_tc, "f").getContractState(address)).state === 'active';
        }
    }
    async waitForDeploy(address, attempts = 10, sleepDuration = 2000) {
        if (attempts <= 0) {
            throw new Error('Attempt number must be positive');
        }
        for (let i = 1; i <= attempts; i++) {
            __classPrivateFieldGet(this, _NetworkProviderImpl_ui, "f").setActionPrompt(`Awaiting contract deployment... [Attempt ${i}/${attempts}]`);
            const isDeployed = await this.isContractDeployed(address);
            if (isDeployed) {
                __classPrivateFieldGet(this, _NetworkProviderImpl_ui, "f").clearActionPrompt();
                __classPrivateFieldGet(this, _NetworkProviderImpl_ui, "f").write(`Contract deployed at address ${address.toString()}`);
                __classPrivateFieldGet(this, _NetworkProviderImpl_ui, "f").write(`You can view it at ${(0, utils_1.getExplorerLink)(address.toString(), __classPrivateFieldGet(this, _NetworkProviderImpl_network, "f"), __classPrivateFieldGet(this, _NetworkProviderImpl_explorer, "f"))}`);
                return;
            }
            await (0, utils_1.sleep)(sleepDuration);
        }
        __classPrivateFieldGet(this, _NetworkProviderImpl_ui, "f").clearActionPrompt();
        throw new Error("Contract was not deployed. Check your wallet's transactions");
    }
    /**
     * @deprecated
     *
     * Use your Contract's `sendDeploy` method (or similar) together with `waitForDeploy` instead.
     */
    async deploy(contract, value, body, waitAttempts = 10) {
        const isDeployed = await this.isContractDeployed(contract.address);
        if (isDeployed) {
            throw new Error('Contract is already deployed!');
        }
        if (!contract.init) {
            throw new Error('Contract has no init!');
        }
        await __classPrivateFieldGet(this, _NetworkProviderImpl_sender, "f").send({
            to: contract.address,
            value,
            body,
            init: contract.init,
        });
        if (waitAttempts <= 0)
            return;
        await this.waitForDeploy(contract.address, waitAttempts);
    }
    open(contract) {
        return (0, core_1.openContract)(contract, (params) => this.provider(params.address, params.init ?? null));
    }
    ui() {
        return __classPrivateFieldGet(this, _NetworkProviderImpl_ui, "f");
    }
}
_NetworkProviderImpl_tc = new WeakMap(), _NetworkProviderImpl_sender = new WeakMap(), _NetworkProviderImpl_network = new WeakMap(), _NetworkProviderImpl_explorer = new WeakMap(), _NetworkProviderImpl_ui = new WeakMap();
async function createMnemonicProvider(client, ui) {
    const mnemonic = process.env.WALLET_MNEMONIC ?? '';
    const walletVersion = process.env.WALLET_VERSION ?? '';
    if (mnemonic.length === 0 || walletVersion.length === 0) {
        throw new Error('Mnemonic deployer was chosen, but env variables WALLET_MNEMONIC and WALLET_VERSION are not set');
    }
    const keyPair = await (0, crypto_1.mnemonicToPrivateKey)(mnemonic.split(' '));
    return new MnemonicProvider_1.MnemonicProvider({
        version: walletVersion.toLowerCase(),
        client,
        secretKey: keyPair.secretKey,
        ui,
    });
}
class NetworkProviderBuilder {
    constructor(args, ui, config, allowCustom = true) {
        this.args = args;
        this.ui = ui;
        this.config = config;
        this.allowCustom = allowCustom;
    }
    async chooseNetwork() {
        let network = (0, utils_1.oneOrZeroOf)({
            mainnet: this.args['--mainnet'],
            testnet: this.args['--testnet'],
            custom: this.args['--custom'] !== undefined,
        });
        if (network !== undefined) {
            return network;
        }
        if (this.config?.network !== undefined) {
            return typeof this.config.network === 'string' ? this.config.network : 'custom';
        }
        network = await this.ui.choose('Which network do you want to use?', ['mainnet', 'testnet', 'custom'], (c) => c);
        if (network === 'custom') {
            const defaultCustomEndpoint = 'http://localhost:8081/';
            this.args['--custom'] = (await this.ui.input(`Provide a custom API v2 endpoint (default is ${defaultCustomEndpoint})`)).trim();
            if (this.args['--custom'] === '')
                this.args['--custom'] = defaultCustomEndpoint;
        }
        return network;
    }
    chooseExplorer() {
        return ((0, utils_1.oneOrZeroOf)({
            tonscan: this.args['--tonscan'],
            tonviewer: this.args['--tonviewer'],
            toncx: this.args['--toncx'],
            dton: this.args['--dton'],
        }) ?? 'tonscan');
    }
    async chooseSendProvider(network, client) {
        let deployUsing = (0, utils_1.oneOrZeroOf)({
            tonconnect: this.args['--tonconnect'],
            deeplink: this.args['--deeplink'],
            tonhub: this.args['--tonhub'],
            mnemonic: this.args['--mnemonic'],
        });
        if (!deployUsing) {
            deployUsing = (await this.ui.choose('Which wallet are you using?', [
                {
                    name: 'TON Connect compatible mobile wallet (example: Tonkeeper)',
                    value: 'tonconnect',
                },
                {
                    name: 'Create a ton:// deep link',
                    value: 'deeplink',
                },
                {
                    name: 'Tonhub wallet',
                    value: 'tonhub',
                },
                {
                    name: 'Mnemonic',
                    value: 'mnemonic',
                },
            ], (c) => c.name)).value;
        }
        const storagePath = path_1.default.join(paths_1.TEMP_DIR, network, deployUsing + '.json');
        let provider;
        switch (deployUsing) {
            case 'deeplink':
                provider = new DeeplinkProvider_1.DeeplinkProvider(this.ui);
                break;
            case 'tonconnect':
                if (network === 'custom')
                    throw new Error('Tonkeeper cannot work with custom network.');
                provider = new TonConnectProvider_1.TonConnectProvider(new FSStorage_1.FSStorage(storagePath), this.ui);
                break;
            case 'tonhub':
                if (network === 'custom')
                    throw new Error('TonHub cannot work with custom network.');
                provider = new TonHubProvider_1.TonHubProvider(network, new FSStorage_1.FSStorage(storagePath), this.ui);
                break;
            case 'mnemonic':
                provider = await createMnemonicProvider(client, this.ui);
                break;
            default:
                throw new Error('Unknown deploy option');
        }
        return provider;
    }
    async build() {
        let network = await this.chooseNetwork();
        const explorer = this.chooseExplorer();
        if (network !== 'custom' &&
            (this.args['--custom-key'] !== undefined ||
                this.args['--custom-type'] !== undefined ||
                this.args['--custom-version'] !== undefined)) {
            throw new Error('Cannot use custom parameters with a non-custom network');
        }
        let tc;
        if (network === 'custom') {
            let configNetwork = undefined;
            if (this.config?.network !== undefined && typeof this.config.network !== 'string') {
                configNetwork = this.config.network;
            }
            if (this.args['--custom'] !== undefined) {
                const inputVer = this.args['--custom-version'];
                let version = undefined;
                if (inputVer !== undefined) {
                    version = inputVer.toLowerCase(); // checks come later
                }
                const inputType = this.args['--custom-type'];
                let type = undefined;
                if (inputType !== undefined) {
                    type = inputType; // checks come later
                }
                configNetwork = {
                    endpoint: this.args['--custom'],
                    version,
                    key: this.args['--custom-key'],
                    type,
                };
            }
            if (configNetwork === undefined) {
                throw new Error('Custom network is (somehow) undefined');
            }
            if (configNetwork.version === undefined || configNetwork.version === 'v2') {
                tc = new ton_1.TonClient({
                    endpoint: configNetwork.endpoint,
                    apiKey: configNetwork.key,
                });
            }
            else if (configNetwork.version === 'v4') {
                if (configNetwork.key !== undefined) {
                    throw new Error('Cannot use a custom API key with a v4 API');
                }
                tc = new ton_1.TonClient4({
                    endpoint: configNetwork.endpoint,
                });
            }
            else {
                throw new Error('Unknown API version: ' + configNetwork.version);
            }
            if (configNetwork.type !== undefined) {
                const ct = configNetwork.type.toLowerCase();
                if (!['mainnet', 'testnet', 'custom'].includes(ct)) {
                    throw new Error('Unknown network type: ' + ct);
                }
                network = ct;
            }
            else if (!this.allowCustom) {
                throw new Error('The usage of this network provider requires either mainnet or testnet');
            }
        }
        else {
            tc = new ton_1.TonClient4({
                endpoint: await (0, ton_access_1.getHttpV4Endpoint)({ network }),
            });
        }
        const sendProvider = await this.chooseSendProvider(network, tc);
        try {
            await sendProvider.connect();
        }
        catch (e) {
            console.error('Unable to connect to wallet.');
            process.exit(1);
        }
        finally {
            this.ui.setActionPrompt('');
        }
        const sender = new SendProviderSender(sendProvider);
        return new NetworkProviderImpl(tc, sender, network, explorer, this.ui);
    }
}
async function createNetworkProvider(ui, args, config, allowCustom = true) {
    return await new NetworkProviderBuilder(args, ui, config, allowCustom).build();
}
exports.createNetworkProvider = createNetworkProvider;
