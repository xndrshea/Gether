"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.idTextErr = exports.throwConstEvalError = exports.throwInternalCompilerError = exports.throwCompilationError = exports.throwSyntaxError = exports.throwParseError = exports.TactConstEvalError = exports.TactInternalCompilerError = exports.TactCompilationError = exports.TactSyntaxError = exports.TactParseError = exports.TactError = void 0;
const path_1 = __importDefault(require("path"));
const process_1 = require("process");
const ast_1 = require("./grammar/ast");
class TactError extends Error {
    loc;
    constructor(message, loc) {
        super(message);
        this.loc = loc;
    }
}
exports.TactError = TactError;
class TactParseError extends TactError {
    constructor(message, loc) {
        super(message, loc);
    }
}
exports.TactParseError = TactParseError;
class TactSyntaxError extends TactError {
    constructor(message, loc) {
        super(message, loc);
    }
}
exports.TactSyntaxError = TactSyntaxError;
/// This will be split at least into two categories: typechecking and codegen errors
class TactCompilationError extends TactError {
    constructor(message, loc) {
        super(message, loc);
    }
}
exports.TactCompilationError = TactCompilationError;
class TactInternalCompilerError extends TactError {
    constructor(message, loc) {
        super(message, loc);
    }
}
exports.TactInternalCompilerError = TactInternalCompilerError;
class TactConstEvalError extends TactCompilationError {
    fatal = false;
    constructor(message, fatal, loc) {
        super(message, loc);
        this.fatal = fatal;
    }
}
exports.TactConstEvalError = TactConstEvalError;
function locationStr(sourceInfo) {
    if (sourceInfo.file) {
        const loc = sourceInfo.interval.getLineAndColumn();
        const file = path_1.default.relative((0, process_1.cwd)(), sourceInfo.file);
        return `${file}:${loc.lineNum}:${loc.colNum}: `;
    }
    else {
        return "";
    }
}
function throwParseError(matchResult, path, origin) {
    const interval = matchResult.getInterval();
    const source = new ast_1.SrcInfo(interval, path, origin);
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const message = `Parse error: expected ${matchResult.getExpectedText()}\n`;
    throw new TactParseError(`${locationStr(source)}${message}\n${interval.getLineAndColumnMessage()}`, source);
}
exports.throwParseError = throwParseError;
function throwSyntaxError(message, source) {
    throw new TactSyntaxError(`Syntax error: ${locationStr(source)}${message}\n${source.interval.getLineAndColumnMessage()}`, source);
}
exports.throwSyntaxError = throwSyntaxError;
function throwCompilationError(message, source) {
    const msg = source === undefined
        ? message
        : `${locationStr(source)}${message}\n${source.interval.getLineAndColumnMessage()}`;
    throw new TactCompilationError(msg, source);
}
exports.throwCompilationError = throwCompilationError;
function throwInternalCompilerError(message, source) {
    const msg = `[INTERNAL COMPILER ERROR]: ${message}\nPlease report at https://github.com/tact-lang/tact/issues`;
    throw source === undefined
        ? new TactInternalCompilerError(msg)
        : new TactInternalCompilerError(`${locationStr(source)}\n${msg}\n${source.interval.getLineAndColumnMessage()}`, source);
}
exports.throwInternalCompilerError = throwInternalCompilerError;
function throwConstEvalError(message, fatal, source) {
    throw new TactConstEvalError(`${locationStr(source)}${message}\n${source.interval.getLineAndColumnMessage()}`, fatal, source);
}
exports.throwConstEvalError = throwConstEvalError;
function idTextErr(ident) {
    if (typeof ident === "string") {
        return `"${ident}"`;
    }
    return `"${ident.text}"`;
}
exports.idTextErr = idTextErr;
