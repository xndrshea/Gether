"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAllExpressionTypes = exports.resolveExpression = exports.getExpType = void 0;
const ast_1 = require("../grammar/ast");
const errors_1 = require("../errors");
const context_1 = require("../context");
const resolveDescriptors_1 = require("./resolveDescriptors");
const types_1 = require("./types");
const map_1 = require("../abi/map");
const global_1 = require("../abi/global");
const subtyping_1 = require("./subtyping");
const errors_2 = require("../errors");
const struct_1 = require("../abi/struct");
const store = (0, context_1.createContextStore)();
function getExpType(ctx, exp) {
    const t = store.get(ctx, exp.id);
    if (!t) {
        (0, errors_2.throwInternalCompilerError)(`Expression ${exp.id} not found`);
    }
    return t.description;
}
exports.getExpType = getExpType;
function registerExpType(ctx, exp, description) {
    const ex = store.get(ctx, exp.id);
    if (ex) {
        if ((0, types_1.typeRefEquals)(ex.description, description)) {
            return ctx;
        }
        (0, errors_2.throwInternalCompilerError)(`Expression ${exp.id} already has a type`);
    }
    return store.set(ctx, exp.id, { ast: exp, description });
}
function resolveBooleanLiteral(exp, sctx, ctx) {
    return registerExpType(ctx, exp, {
        kind: "ref",
        name: "Bool",
        optional: false,
    });
}
function resolveIntLiteral(exp, sctx, ctx) {
    return registerExpType(ctx, exp, {
        kind: "ref",
        name: "Int",
        optional: false,
    });
}
function resolveNullLiteral(exp, sctx, ctx) {
    return registerExpType(ctx, exp, { kind: "null" });
}
function resolveStringLiteral(exp, sctx, ctx) {
    return registerExpType(ctx, exp, {
        kind: "ref",
        name: "String",
        optional: false,
    });
}
function resolveStructNew(exp, sctx, ctx) {
    // Get type
    const tp = (0, resolveDescriptors_1.getType)(ctx, exp.type);
    if (tp.kind !== "struct") {
        (0, errors_1.throwCompilationError)(`Invalid type ${(0, errors_1.idTextErr)(exp.type)} for construction`, exp.loc);
    }
    // Process fields
    const processed = new Set();
    for (const e of exp.args) {
        // Check duplicates
        if (processed.has((0, ast_1.idText)(e.field))) {
            (0, errors_1.throwCompilationError)(`Duplicate fields ${(0, errors_1.idTextErr)(e.field)}`, e.loc);
        }
        processed.add((0, ast_1.idText)(e.field));
        // Check existing
        const f = tp.fields.find((v) => (0, ast_1.eqNames)(v.name, e.field));
        if (!f) {
            (0, errors_1.throwCompilationError)(`Unknown fields ${(0, errors_1.idTextErr)(e.field)} in type ${(0, errors_1.idTextErr)(tp.name)}`, e.loc);
        }
        // Resolve expression
        ctx = resolveExpression(e.initializer, sctx, ctx);
        // Check expression type
        const expressionType = getExpType(ctx, e.initializer);
        if (!(0, subtyping_1.isAssignable)(expressionType, f.type)) {
            (0, errors_1.throwCompilationError)(`Invalid type "${(0, types_1.printTypeRef)(expressionType)}" for field ${(0, errors_1.idTextErr)(e.field)} with type "${(0, types_1.printTypeRef)(f.type)}" in type "${tp.name}"`, e.loc);
        }
    }
    // Check missing fields
    for (const f of tp.fields) {
        if (!processed.has(f.name) &&
            f.ast.initializer === null &&
            !(f.type.kind === "ref" && f.type.optional)) {
            (0, errors_1.throwCompilationError)(`Missing field "${f.name}" in type "${tp.name}"`, exp.loc);
        }
    }
    // Register result
    return registerExpType(ctx, exp, {
        kind: "ref",
        name: tp.name,
        optional: false,
    });
}
function resolveBinaryOp(exp, sctx, ctx) {
    // Resolve left and right expressions
    ctx = resolveExpression(exp.left, sctx, ctx);
    ctx = resolveExpression(exp.right, sctx, ctx);
    const le = getExpType(ctx, exp.left);
    const re = getExpType(ctx, exp.right);
    // Check operands
    let resolved;
    switch (exp.op) {
        case "-":
        case "+":
        case "*":
        case "/":
        case "%":
        case ">>":
        case "<<":
        case "&":
        case "|":
        case "^":
            {
                if (le.kind !== "ref" || le.optional || le.name !== "Int") {
                    (0, errors_1.throwCompilationError)(`Invalid type "${(0, types_1.printTypeRef)(le)}" for binary operator "${exp.op}"`, exp.loc);
                }
                if (re.kind !== "ref" || re.optional || re.name !== "Int") {
                    (0, errors_1.throwCompilationError)(`Invalid type "${(0, types_1.printTypeRef)(re)}" for binary operator "${exp.op}"`, exp.loc);
                }
                resolved = { kind: "ref", name: "Int", optional: false };
            }
            break;
        case "<":
        case "<=":
        case ">":
        case ">=":
            {
                if (le.kind !== "ref" || le.optional || le.name !== "Int") {
                    (0, errors_1.throwCompilationError)(`Invalid type "${(0, types_1.printTypeRef)(le)}" for binary operator "${exp.op}"`, exp.loc);
                }
                if (re.kind !== "ref" || re.optional || re.name !== "Int") {
                    (0, errors_1.throwCompilationError)(`Invalid type "${(0, types_1.printTypeRef)(re)}" for binary operator "${exp.op}"`, exp.loc);
                }
                resolved = { kind: "ref", name: "Bool", optional: false };
            }
            break;
        case "==":
        case "!=":
            {
                // any inhabitant of an optional type can be compared to null
                if ((le.kind === "ref" && le.optional && re.kind === "null") ||
                    (re.kind === "ref" && re.optional && le.kind === "null")) {
                    resolved = { kind: "ref", name: "Bool", optional: false };
                    break;
                }
                if (!isEqualityType(ctx, le)) {
                    (0, errors_1.throwCompilationError)(`Expressions of "${(0, types_1.printTypeRef)(le)}" type cannot be used for (non)equality operator "${exp.op}"\n See https://docs.tact-lang.org/book/operators#binary-equality`, exp.loc);
                }
                if (!isEqualityType(ctx, re)) {
                    (0, errors_1.throwCompilationError)(`Expressions of "${(0, types_1.printTypeRef)(re)}" type cannot be used for (non)equality operator "${exp.op}"\nSee https://docs.tact-lang.org/book/operators#binary-equality`, exp.loc);
                }
                if (!(0, subtyping_1.isAssignable)(le, re) && !(0, subtyping_1.isAssignable)(re, le)) {
                    (0, errors_1.throwCompilationError)(`Incompatible types "${(0, types_1.printTypeRef)(le)}" and "${(0, types_1.printTypeRef)(re)}" for binary operator "${exp.op}"`, exp.loc);
                }
                resolved = { kind: "ref", name: "Bool", optional: false };
            }
            break;
        case "&&":
        case "||": {
            if (le.kind !== "ref" || le.optional || le.name !== "Bool") {
                (0, errors_1.throwCompilationError)(`Invalid type "${(0, types_1.printTypeRef)(le)}" for binary operator "${exp.op}"`, exp.loc);
            }
            if (re.kind !== "ref" || re.optional || re.name !== "Bool") {
                (0, errors_1.throwCompilationError)(`Invalid type "${(0, types_1.printTypeRef)(re)}" for binary operator "${exp.op}"`, exp.loc);
            }
            resolved = { kind: "ref", name: "Bool", optional: false };
        }
    }
    // Register result
    return registerExpType(ctx, exp, resolved);
}
function isEqualityType(ctx, ty) {
    switch (ty.kind) {
        case "ref": {
            const type = (0, resolveDescriptors_1.getType)(ctx, ty.name);
            if (type.kind === "primitive_type_decl") {
                return (ty.name === "Int" ||
                    ty.name === "Bool" ||
                    ty.name === "Address" ||
                    ty.name === "Cell" ||
                    ty.name === "Slice" ||
                    ty.name === "String");
            }
            else {
                return false;
            }
        }
        case "null":
        case "map":
            return true;
        case "void":
        case "ref_bounced":
            return false;
    }
}
function resolveUnaryOp(exp, sctx, ctx) {
    // Resolve right side
    ctx = resolveExpression(exp.operand, sctx, ctx);
    // Check right type dependent on operator
    let resolvedType = getExpType(ctx, exp.operand);
    switch (exp.op) {
        case "-":
        case "+":
        case "~":
            {
                if (resolvedType.kind !== "ref" ||
                    resolvedType.optional ||
                    resolvedType.name !== "Int") {
                    (0, errors_1.throwCompilationError)(`Invalid type "${(0, types_1.printTypeRef)(resolvedType)}" for unary operator "${exp.op}"`, exp.loc);
                }
            }
            break;
        case "!":
            {
                if (resolvedType.kind !== "ref" ||
                    resolvedType.optional ||
                    resolvedType.name !== "Bool") {
                    (0, errors_1.throwCompilationError)(`Invalid type "${(0, types_1.printTypeRef)(resolvedType)}" for unary operator "${exp.op}"`, exp.loc);
                }
            }
            break;
        case "!!": {
            if (resolvedType.kind !== "ref" || !resolvedType.optional) {
                (0, errors_1.throwCompilationError)(`Type "${(0, types_1.printTypeRef)(resolvedType)}" is not optional`, exp.loc);
            }
            resolvedType = {
                kind: "ref",
                name: resolvedType.name,
                optional: false,
            };
        }
    }
    // Register result
    return registerExpType(ctx, exp, resolvedType);
}
function resolveFieldAccess(exp, sctx, ctx) {
    // Resolve expression
    ctx = resolveExpression(exp.aggregate, sctx, ctx);
    // Find target type and check for type
    const src = getExpType(ctx, exp.aggregate);
    if ((src.kind !== "ref" || src.optional) && src.kind !== "ref_bounced") {
        (0, errors_1.throwCompilationError)(`Invalid type "${(0, types_1.printTypeRef)(src)}" for field access`, exp.loc);
    }
    // Check if field initialized
    if (sctx.requiredFields.length > 0 &&
        exp.aggregate.kind === "id" &&
        exp.aggregate.text === "self") {
        if (sctx.requiredFields.find((v) => (0, ast_1.eqNames)(v, exp.field))) {
            (0, errors_1.throwCompilationError)(`Field ${(0, errors_1.idTextErr)(exp.field)} is not initialized`, exp.field.loc);
        }
    }
    // Find field
    let fields;
    const srcT = (0, resolveDescriptors_1.getType)(ctx, src.name);
    fields = srcT.fields;
    if (src.kind === "ref_bounced") {
        fields = fields.slice(0, srcT.partialFieldCount);
    }
    const field = fields.find((v) => (0, ast_1.eqNames)(v.name, exp.field));
    const cst = srcT.constants.find((v) => (0, ast_1.eqNames)(v.name, exp.field));
    if (!field && !cst) {
        const typeStr = src.kind === "ref_bounced"
            ? `bounced<${(0, errors_1.idTextErr)(src.name)}>`
            : (0, errors_1.idTextErr)(src.name);
        if (src.kind === "ref" && !src.optional) {
            // Check for struct methods
            if ((srcT.kind === "struct" &&
                struct_1.StructFunctions.has((0, ast_1.idText)(exp.field))) ||
                srcT.functions.has((0, ast_1.idText)(exp.field))) {
                (0, errors_1.throwCompilationError)(`Type ${typeStr} does not have a field named "${exp.field.text}", did you mean "${exp.field.text}()" instead?`, exp.loc);
            }
        }
        (0, errors_1.throwCompilationError)(`Type ${typeStr} does not have a field named ${(0, errors_1.idTextErr)(exp.field)}`, exp.field.loc);
    }
    // Register result type
    if (field) {
        return registerExpType(ctx, exp, field.type);
    }
    else {
        return registerExpType(ctx, exp, cst.type);
    }
}
function resolveStaticCall(exp, sctx, ctx) {
    // Check if abi global function
    if (global_1.GlobalFunctions.has((0, ast_1.idText)(exp.function))) {
        const f = global_1.GlobalFunctions.get((0, ast_1.idText)(exp.function));
        // Resolve arguments
        for (const e of exp.args) {
            ctx = resolveExpression(e, sctx, ctx);
        }
        // Resolve return type
        const resolved = f.resolve(ctx, exp.args.map((v) => getExpType(ctx, v)), exp.loc);
        // Register return type
        return registerExpType(ctx, exp, resolved);
    }
    // Check if function exists
    if (!(0, resolveDescriptors_1.hasStaticFunction)(ctx, (0, ast_1.idText)(exp.function))) {
        (0, errors_1.throwCompilationError)(`Static function ${(0, errors_1.idTextErr)(exp.function)} does not exist`, exp.loc);
    }
    // Get static function
    const f = (0, resolveDescriptors_1.getStaticFunction)(ctx, (0, ast_1.idText)(exp.function));
    // Resolve call arguments
    for (const e of exp.args) {
        ctx = resolveExpression(e, sctx, ctx);
    }
    // Check arguments
    if (f.params.length !== exp.args.length) {
        (0, errors_1.throwCompilationError)(`Function ${(0, errors_1.idTextErr)(exp.function)} expects ${f.params.length} arguments, got ${exp.args.length}`, exp.loc);
    }
    for (const [i, a] of f.params.entries()) {
        const e = exp.args[i];
        const t = getExpType(ctx, e);
        if (!(0, subtyping_1.isAssignable)(t, a.type)) {
            (0, errors_1.throwCompilationError)(`Invalid type "${(0, types_1.printTypeRef)(t)}" for argument ${(0, errors_1.idTextErr)(a.name)}`, e.loc);
        }
    }
    // Resolve return type
    return registerExpType(ctx, exp, f.returns);
}
function resolveCall(exp, sctx, ctx) {
    // Resolve expression
    ctx = resolveExpression(exp.self, sctx, ctx);
    // Check if self is initialized
    if (exp.self.kind === "id" &&
        exp.self.text === "self" &&
        sctx.requiredFields.length > 0) {
        (0, errors_1.throwCompilationError)("Cannot access self before init", exp.loc);
    }
    // Resolve args
    for (const e of exp.args) {
        ctx = resolveExpression(e, sctx, ctx);
    }
    // Resolve return value
    const src = getExpType(ctx, exp.self);
    // Handle ref
    if (src.kind === "ref") {
        if (src.optional) {
            (0, errors_1.throwCompilationError)(`Invalid type "${(0, types_1.printTypeRef)(src)}" for function call`, exp.loc);
        }
        // Register return type
        const srcT = (0, resolveDescriptors_1.getType)(ctx, src.name);
        // Check struct ABI
        if (srcT.kind === "struct") {
            if (struct_1.StructFunctions.has((0, ast_1.idText)(exp.method))) {
                const abi = struct_1.StructFunctions.get((0, ast_1.idText)(exp.method));
                const resolved = abi.resolve(ctx, [src, ...exp.args.map((v) => getExpType(ctx, v))], exp.loc);
                return registerExpType(ctx, exp, resolved);
            }
        }
        const f = srcT.functions.get((0, ast_1.idText)(exp.method));
        if (f) {
            // Check arguments
            if (f.params.length !== exp.args.length) {
                (0, errors_1.throwCompilationError)(`Function ${(0, errors_1.idTextErr)(exp.method)} expects ${f.params.length} arguments, got ${exp.args.length}`, exp.loc);
            }
            for (const [i, a] of f.params.entries()) {
                const e = exp.args[i];
                const t = getExpType(ctx, e);
                if (!(0, subtyping_1.isAssignable)(t, a.type)) {
                    (0, errors_1.throwCompilationError)(`Invalid type "${(0, types_1.printTypeRef)(t)}" for argument ${(0, errors_1.idTextErr)(a.name)}`, e.loc);
                }
            }
            return registerExpType(ctx, exp, f.returns);
        }
        // Check if a field with the same name exists
        const field = srcT.fields.find((v) => (0, ast_1.eqNames)(v.name, exp.method));
        if (field) {
            (0, errors_1.throwCompilationError)(`Type "${src.name}" does not have a function named "${exp.method.text}()", did you mean field "${exp.method.text}" instead?`, exp.loc);
        }
        (0, errors_1.throwCompilationError)(`Type "${src.name}" does not have a function named ${(0, errors_1.idTextErr)(exp.method)}`, exp.loc);
    }
    // Handle map
    if (src.kind === "map") {
        if (!map_1.MapFunctions.has((0, ast_1.idText)(exp.method))) {
            (0, errors_1.throwCompilationError)(`Map function ${(0, errors_1.idTextErr)(exp.method)} not found`, exp.loc);
        }
        const abf = map_1.MapFunctions.get((0, ast_1.idText)(exp.method));
        const resolved = abf.resolve(ctx, [src, ...exp.args.map((v) => getExpType(ctx, v))], exp.loc);
        return registerExpType(ctx, exp, resolved);
    }
    if (src.kind === "ref_bounced") {
        (0, errors_1.throwCompilationError)(`Cannot call function on bounced value`, exp.loc);
    }
    (0, errors_1.throwCompilationError)(`Invalid type "${(0, types_1.printTypeRef)(src)}" for function call`, exp.loc);
}
function resolveInitOf(ast, sctx, ctx) {
    // Resolve type
    const type = (0, resolveDescriptors_1.getType)(ctx, ast.contract);
    if (type.kind !== "contract") {
        (0, errors_1.throwCompilationError)(`Type ${(0, errors_1.idTextErr)(ast.contract)} is not a contract`, ast.loc);
    }
    if (!type.init) {
        (0, errors_1.throwCompilationError)(`Contract ${(0, errors_1.idTextErr)(ast.contract)} does not have an init function`, ast.loc);
    }
    // Resolve args
    for (const e of ast.args) {
        ctx = resolveExpression(e, sctx, ctx);
    }
    // Check arguments
    if (type.init.params.length !== ast.args.length) {
        (0, errors_1.throwCompilationError)(`Init function of "${type.name}" expects ${type.init.params.length} arguments, got ${ast.args.length}`, ast.loc);
    }
    for (const [i, a] of type.init.params.entries()) {
        const e = ast.args[i];
        const t = getExpType(ctx, e);
        if (!(0, subtyping_1.isAssignable)(t, a.type)) {
            (0, errors_1.throwCompilationError)(`Invalid type "${(0, types_1.printTypeRef)(t)}" for argument ${(0, errors_1.idTextErr)(a.name)}`, e.loc);
        }
    }
    // Register return type
    return registerExpType(ctx, ast, {
        kind: "ref",
        name: "StateInit",
        optional: false,
    });
}
function resolveConditional(ast, sctx, ctx) {
    ctx = resolveExpression(ast.condition, sctx, ctx);
    const conditionType = getExpType(ctx, ast.condition);
    if (conditionType.kind !== "ref" ||
        conditionType.optional ||
        conditionType.name !== "Bool") {
        (0, errors_1.throwCompilationError)(`Invalid type "${(0, types_1.printTypeRef)(conditionType)}" for ternary condition`, ast.condition.loc);
    }
    ctx = resolveExpression(ast.thenBranch, sctx, ctx);
    ctx = resolveExpression(ast.elseBranch, sctx, ctx);
    const thenType = getExpType(ctx, ast.thenBranch);
    const elseType = getExpType(ctx, ast.elseBranch);
    const resultType = (0, subtyping_1.moreGeneralType)(thenType, elseType);
    if (resultType) {
        if (resultType.kind == "void") {
            (0, errors_1.throwCompilationError)(`Expressions of "<void>" type cannot be used for conditional expression`, ast.loc);
        }
        return registerExpType(ctx, ast, resultType);
    }
    (0, errors_1.throwCompilationError)(`Non-matching types "${(0, types_1.printTypeRef)(thenType)}" and "${(0, types_1.printTypeRef)(elseType)}" for ternary branches`, ast.elseBranch.loc);
}
function resolveExpression(exp, sctx, ctx) {
    switch (exp.kind) {
        case "boolean": {
            return resolveBooleanLiteral(exp, sctx, ctx);
        }
        case "number": {
            return resolveIntLiteral(exp, sctx, ctx);
        }
        case "null": {
            return resolveNullLiteral(exp, sctx, ctx);
        }
        case "string": {
            return resolveStringLiteral(exp, sctx, ctx);
        }
        case "struct_instance": {
            return resolveStructNew(exp, sctx, ctx);
        }
        case "op_binary": {
            return resolveBinaryOp(exp, sctx, ctx);
        }
        case "op_unary": {
            return resolveUnaryOp(exp, sctx, ctx);
        }
        case "id": {
            // Find variable
            const v = sctx.vars.get(exp.text);
            if (!v) {
                if (!(0, resolveDescriptors_1.hasStaticConstant)(ctx, exp.text)) {
                    if ((0, ast_1.isWildcard)(exp)) {
                        (0, errors_1.throwCompilationError)("Wildcard variable name '_' cannot be accessed", exp.loc);
                    }
                    // Handle static struct method calls
                    try {
                        const t = (0, resolveDescriptors_1.getType)(ctx, exp.text);
                        if (t.kind === "struct") {
                            return registerExpType(ctx, exp, {
                                kind: "ref",
                                name: t.name,
                                optional: false,
                            });
                        }
                    }
                    catch {
                        // Ignore
                    }
                    // Handle possible field access and suggest to use self.field instead
                    const self = sctx.vars.get("self");
                    if (self && self.kind === "ref") {
                        const t = (0, resolveDescriptors_1.getType)(ctx, self.name);
                        if (t.kind === "contract" || t.kind === "trait") {
                            const field = t.fields.find((f) => f.name == exp.text);
                            if (field) {
                                (0, errors_1.throwCompilationError)(`Unable to resolve id '${exp.text}', did you mean 'self.${exp.text}'?`, exp.loc);
                            }
                        }
                    }
                    (0, errors_1.throwCompilationError)(`Unable to resolve id '${exp.text}'`, exp.loc);
                }
                else {
                    const cc = (0, resolveDescriptors_1.getStaticConstant)(ctx, exp.text);
                    return registerExpType(ctx, exp, cc.type);
                }
            }
            return registerExpType(ctx, exp, v);
        }
        case "field_access": {
            return resolveFieldAccess(exp, sctx, ctx);
        }
        case "static_call": {
            return resolveStaticCall(exp, sctx, ctx);
        }
        case "method_call": {
            return resolveCall(exp, sctx, ctx);
        }
        case "init_of": {
            return resolveInitOf(exp, sctx, ctx);
        }
        case "conditional": {
            return resolveConditional(exp, sctx, ctx);
        }
    }
}
exports.resolveExpression = resolveExpression;
function getAllExpressionTypes(ctx) {
    const res = [];
    Object.values(store.all(ctx)).forEach((val) => {
        res.push([val.ast.loc.contents, (0, types_1.printTypeRef)(val.description)]);
    });
    return res;
}
exports.getAllExpressionTypes = getAllExpressionTypes;
