"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.typeRefEquals = exports.printTypeRef = exports.receiverSelectorName = exports.showValue = exports.CommentValue = void 0;
const core_1 = require("@ton/core");
const errors_1 = require("../errors");
const grammar_1 = require("../grammar/grammar");
class CommentValue {
    comment;
    constructor(comment) {
        this.comment = comment;
    }
}
exports.CommentValue = CommentValue;
function showValue(val) {
    if (typeof val === "bigint") {
        return val.toString(10);
    }
    else if (typeof val === "string") {
        return val;
    }
    else if (typeof val === "boolean") {
        return val ? "true" : "false";
    }
    else if (core_1.Address.isAddress(val)) {
        return val.toRawString();
    }
    else if (val instanceof core_1.Cell) {
        return val.toString();
    }
    else if (val === null) {
        return "null";
    }
    else if (val instanceof CommentValue) {
        return val.comment;
    }
    else if (typeof val === "object" && "$tactStruct" in val) {
        const assocList = Object.entries(val).map(([key, value]) => {
            return `${key}: ${showValue(value)}`;
        });
        return `{${assocList.join(",")}}`;
    }
    else {
        (0, errors_1.throwInternalCompilerError)("Invalid value", grammar_1.dummySrcInfo);
    }
}
exports.showValue = showValue;
// TODO: improve this for empty and fallbacks
function receiverSelectorName(selector) {
    switch (selector.kind) {
        case "internal-binary":
        case "bounce-binary":
        case "external-binary":
            return selector.type;
        case "internal-comment":
        case "external-comment":
            return selector.comment;
        case "internal-empty":
        case "external-empty":
            return selector.kind;
        case "internal-fallback":
        case "bounce-fallback":
        case "external-fallback":
            return selector.kind;
        case "internal-comment-fallback":
        case "external-comment-fallback":
            return selector.kind;
    }
}
exports.receiverSelectorName = receiverSelectorName;
function printTypeRef(src) {
    switch (src.kind) {
        case "ref":
            return `${src.name}${src.optional ? "?" : ""}`;
        case "map":
            return `map<${src.key + (src.keyAs ? " as " + src.keyAs : "")}, ${src.value + (src.valueAs ? " as " + src.valueAs : "")}>`;
        case "void":
            return "<void>";
        case "null":
            return "<null>";
        case "ref_bounced":
            return `bounced<${src.name}>`;
    }
}
exports.printTypeRef = printTypeRef;
function typeRefEquals(a, b) {
    if (a.kind !== b.kind) {
        return false;
    }
    if (a.kind === "ref" && b.kind === "ref") {
        return a.name === b.name && a.optional === b.optional;
    }
    if (a.kind === "map" && b.kind === "map") {
        return a.key === b.key && a.value === b.value;
    }
    if (a.kind === "ref_bounced" && b.kind === "ref_bounced") {
        return a.name === b.name;
    }
    if (a.kind === "null" && b.kind === "null") {
        return true;
    }
    if (a.kind === "void" && b.kind === "void") {
        return true;
    }
    return false;
}
exports.typeRefEquals = typeRefEquals;
