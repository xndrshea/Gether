"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseImports = exports.parseExpression = exports.parse = exports.dummySrcInfo = exports.SrcInfo = void 0;
const ohm_js_1 = require("ohm-js");
const grammar_ohm_bundle_1 = __importDefault(require("./grammar.ohm-bundle"));
const errors_1 = require("../errors");
const ast_1 = require("./ast");
const errors_2 = require("../errors");
const checkVariableName_1 = require("./checkVariableName");
const checkFunctionAttributes_1 = require("./checkFunctionAttributes");
const checkConstAttributes_1 = require("./checkConstAttributes");
let ctx;
/**
 * Information about source code location (file and interval within it)
 * and the source code contents.
 */
class SrcInfo {
    #interval;
    #file;
    #origin;
    constructor(interval, file, origin) {
        this.#interval = interval;
        this.#file = file;
        this.#origin = origin;
    }
    get file() {
        return this.#file;
    }
    get contents() {
        return this.#interval.contents;
    }
    get interval() {
        return this.#interval;
    }
    get origin() {
        return this.#origin;
    }
}
exports.SrcInfo = SrcInfo;
const DummyGrammar = (0, ohm_js_1.grammar)("Dummy { DummyRule = any }");
const DUMMY_INTERVAL = DummyGrammar.match("").getInterval();
exports.dummySrcInfo = new SrcInfo(DUMMY_INTERVAL, null, "user");
let currentFile = null;
function inFile(path, callback) {
    currentFile = path;
    const r = callback();
    currentFile = null;
    return r;
}
function createRef(s) {
    return new SrcInfo(s.source, currentFile, ctx.origin);
}
// helper to unwrap optional grammar elements (marked with "?")
// ohm-js represents those essentially as lists (IterationNodes)
function unwrapOptNode(optional, f) {
    const optNode = optional.children[0];
    return optNode !== undefined ? f(optNode) : null;
}
const semantics = grammar_ohm_bundle_1.default.createSemantics();
semantics.addOperation("astOfModule", {
    Module(imports, items) {
        return (0, ast_1.createAstNode)({
            kind: "module",
            imports: imports.children.map((item) => item.astOfImport()),
            items: items.children.map((item) => item.astOfModuleItem()),
        });
    },
});
semantics.addOperation("astOfImport", {
    Import(_importKwd, path, _semicolon) {
        const pathAST = path.astOfExpression();
        if (pathAST.value.includes("\\")) {
            (0, errors_2.throwSyntaxError)('Import path can\'t contain "\\"', createRef(path));
        }
        return (0, ast_1.createAstNode)({
            kind: "import",
            path: pathAST,
            loc: createRef(this),
        });
    },
});
semantics.addOperation("astOfJustImports", {
    JustImports(imports, _restOfInput) {
        return imports.children.map((item) => item.astOfImport());
    },
});
semantics.addOperation("astOfModuleItem", {
    PrimitiveTypeDecl(_primitive_kwd, typeId, _semicolon) {
        (0, checkVariableName_1.checkVariableName)(typeId.sourceString, createRef(typeId));
        return (0, ast_1.createAstNode)({
            kind: "primitive_type_decl",
            name: typeId.astOfType(),
            loc: createRef(this),
        });
    },
    NativeFunctionDecl(_name, _lparen1, funcId, _rparen1, funAttributes, _nativeKwd, tactId, params, _optColon, optReturnType, _semicolon) {
        (0, checkVariableName_1.checkVariableName)(tactId.sourceString, createRef(tactId));
        return (0, ast_1.createAstNode)({
            kind: "native_function_decl",
            attributes: funAttributes.children.map((a) => a.astOfFunctionAttributes()),
            name: tactId.astOfExpression(),
            nativeName: funcId.astOfExpression(),
            return: unwrapOptNode(optReturnType, (t) => t.astOfType()),
            params: params.astsOfList(),
            loc: createRef(this),
        });
    },
    StructDecl_regular(_structKwd, typeId, _lbrace, fields, _rbrace) {
        (0, checkVariableName_1.checkVariableName)(typeId.sourceString, createRef(typeId));
        return (0, ast_1.createAstNode)({
            kind: "struct_decl",
            name: typeId.astOfType(),
            fields: fields.astsOfList(),
            loc: createRef(this),
        });
    },
    StructDecl_message(_messageKwd, _optLparen, optIntMsgId, _optRparen, typeId, _lbrace, fields, _rbrace) {
        (0, checkVariableName_1.checkVariableName)(typeId.sourceString, createRef(typeId));
        return (0, ast_1.createAstNode)({
            kind: "message_decl",
            name: typeId.astOfType(),
            fields: fields.astsOfList(),
            opcode: unwrapOptNode(optIntMsgId, (number) => Number(bigintOfIntLiteral(number))),
            loc: createRef(this),
        });
    },
    Contract(attributes, _contractKwd, contractId, _optWithKwd, optInheritedTraits, _lbrace, contractItems, _rbrace) {
        (0, checkVariableName_1.checkVariableName)(contractId.sourceString, createRef(contractId));
        return (0, ast_1.createAstNode)({
            kind: "contract",
            name: contractId.astOfExpression(),
            attributes: attributes.children.map((ca) => ca.astOfContractAttributes()),
            declarations: contractItems.children.map((item) => item.astOfItem()),
            traits: optInheritedTraits.children[0]?.astsOfList() ?? [],
            loc: createRef(this),
        });
    },
    Trait(attributes, _traitKwd, traitId, _optWithKwd, optInheritedTraits, _lbrace, traitItems, _rbrace) {
        (0, checkVariableName_1.checkVariableName)(traitId.sourceString, createRef(traitId));
        return (0, ast_1.createAstNode)({
            kind: "trait",
            name: traitId.astOfExpression(),
            attributes: attributes.children.map((ca) => ca.astOfContractAttributes()),
            declarations: traitItems.children.map((item) => item.astOfItem()),
            traits: optInheritedTraits.children[0]?.astsOfList() ?? [],
            loc: createRef(this),
        });
    },
    ModuleFunction(fun) {
        return fun.astOfItem();
    },
    ModuleConstant(constant) {
        const astConstDef = constant.astOfItem();
        if (astConstDef.attributes.length !== 0) {
            (0, errors_2.throwSyntaxError)(`Module-level constants do not support attributes`, astConstDef.attributes[0].loc);
        }
        return astConstDef;
    },
});
// top-level (module-level), contract or trait items:
// constant declarations/definitions, functions, receivers,
// getters, etc.
semantics.addOperation("astOfItem", {
    ConstantDefinition(constAttributes, _constKwd, constId, _colon, constType, _equals, initExpr, _semicolon) {
        const attributes = constAttributes.children.map((a) => a.astOfConstAttribute());
        (0, checkConstAttributes_1.checkConstAttributes)(false, attributes, createRef(this));
        return (0, ast_1.createAstNode)({
            kind: "constant_def",
            name: constId.astOfExpression(),
            type: constType.astOfType(),
            initializer: initExpr.astOfExpression(),
            attributes,
            loc: createRef(this),
        });
    },
    ConstantDeclaration(constAttributes, _constKwd, constId, _colon, constType, _semicolon) {
        const attributes = constAttributes.children.map((a) => a.astOfConstAttribute());
        (0, checkConstAttributes_1.checkConstAttributes)(true, attributes, createRef(this));
        return (0, ast_1.createAstNode)({
            kind: "constant_decl",
            name: constId.astOfExpression(),
            type: constType.astOfType(),
            attributes,
            loc: createRef(this),
        });
    },
    StorageVar(fieldDecl, _semicolon) {
        return fieldDecl.astOfDeclaration();
    },
    FunctionDefinition(funAttributes, _funKwd, funId, funParameters, _optColon, optReturnType, _lbrace, funBody, _rbrace) {
        const attributes = funAttributes.children.map((a) => a.astOfFunctionAttributes());
        (0, checkVariableName_1.checkVariableName)(funId.sourceString, createRef(funId));
        (0, checkFunctionAttributes_1.checkFunctionAttributes)(false, attributes, createRef(this));
        return (0, ast_1.createAstNode)({
            kind: "function_def",
            attributes,
            name: funId.astOfExpression(),
            return: unwrapOptNode(optReturnType, (t) => t.astOfType()),
            params: funParameters.astsOfList(),
            statements: funBody.children.map((s) => s.astOfStatement()),
            loc: createRef(this),
        });
    },
    FunctionDeclaration(funAttributes, _funKwd, funId, funParameters, _optColon, optReturnType, _semicolon) {
        const attributes = funAttributes.children.map((a) => a.astOfFunctionAttributes());
        (0, checkVariableName_1.checkVariableName)(funId.sourceString, createRef(funId));
        (0, checkFunctionAttributes_1.checkFunctionAttributes)(true, attributes, createRef(this));
        return (0, ast_1.createAstNode)({
            kind: "function_decl",
            attributes,
            name: funId.astOfExpression(),
            return: unwrapOptNode(optReturnType, (t) => t.astOfType()),
            params: funParameters.astsOfList(),
            loc: createRef(this),
        });
    },
    ContractInit(_initKwd, initParameters, _lbrace, initBody, _rbrace) {
        return (0, ast_1.createAstNode)({
            kind: "contract_init",
            params: initParameters.astsOfList(),
            statements: initBody.children.map((s) => s.astOfStatement()),
            loc: createRef(this),
        });
    },
    Receiver_regular(_receiveKwd, _lparen, optParameter, _rparen, _lbrace, receiverBody, _rbrace) {
        const optParam = optParameter.children[0];
        const selector = optParam
            ? {
                kind: "internal-simple",
                param: optParam.astOfDeclaration(),
            }
            : { kind: "internal-fallback" };
        return (0, ast_1.createAstNode)({
            kind: "receiver",
            selector,
            statements: receiverBody.children.map((s) => s.astOfStatement()),
            loc: createRef(this),
        });
    },
    Receiver_comment(_receiveKwd, _lparen, comment, _rparen, _lbrace, receiverBody, _rbrace) {
        return (0, ast_1.createAstNode)({
            kind: "receiver",
            selector: {
                kind: "internal-comment",
                comment: comment.astOfExpression(),
            },
            statements: receiverBody.children.map((s) => s.astOfStatement()),
            loc: createRef(this),
        });
    },
    Receiver_bounced(_bouncedKwd, _lparen, parameter, _rparen, _lbrace, receiverBody, _rbrace) {
        return (0, ast_1.createAstNode)({
            kind: "receiver",
            selector: { kind: "bounce", param: parameter.astOfDeclaration() },
            statements: receiverBody.children.map((s) => s.astOfStatement()),
            loc: createRef(this),
        });
    },
    Receiver_externalRegular(_externalKwd, _lparen, optParameter, _rparen, _lbrace, receiverBody, _rbrace) {
        const optParam = optParameter.children[0];
        const selector = optParam
            ? {
                kind: "external-simple",
                param: optParam.astOfDeclaration(),
            }
            : { kind: "external-fallback" };
        return (0, ast_1.createAstNode)({
            kind: "receiver",
            selector,
            statements: receiverBody.children.map((s) => s.astOfStatement()),
            loc: createRef(this),
        });
    },
    Receiver_externalComment(_externalKwd, _lparen, comment, _rparen, _lbrace, receiverBody, _rbrace) {
        return (0, ast_1.createAstNode)({
            kind: "receiver",
            selector: {
                kind: "external-comment",
                comment: comment.astOfExpression(),
            },
            statements: receiverBody.children.map((s) => s.astOfStatement()),
            loc: createRef(this),
        });
    },
});
semantics.addOperation("astOfFunctionAttributes", {
    FunctionAttribute_getter(_) {
        return { type: "get", loc: createRef(this) };
    },
    FunctionAttribute_extends(_) {
        return { type: "extends", loc: createRef(this) };
    },
    FunctionAttribute_mutates(_) {
        return { type: "mutates", loc: createRef(this) };
    },
    FunctionAttribute_override(_) {
        return { type: "override", loc: createRef(this) };
    },
    FunctionAttribute_inline(_) {
        return { type: "inline", loc: createRef(this) };
    },
    FunctionAttribute_virtual(_) {
        return { type: "virtual", loc: createRef(this) };
    },
    FunctionAttribute_abstract(_) {
        return { type: "abstract", loc: createRef(this) };
    },
});
semantics.addOperation("astOfConstAttribute", {
    ConstantAttribute_override(_) {
        return { type: "override", loc: createRef(this) };
    },
    ConstantAttribute_virtual(_) {
        return { type: "virtual", loc: createRef(this) };
    },
    ConstantAttribute_abstract(_) {
        return { type: "abstract", loc: createRef(this) };
    },
});
semantics.addOperation("astsOfList", {
    InheritedTraits(traits, _optTrailingComma) {
        return traits
            .asIteration()
            .children.map((id, _comma) => id.astOfExpression());
    },
    StructFields(fields, _optSemicolon) {
        return fields
            .asIteration()
            .children.map((field, _semicolon) => field.astOfDeclaration());
    },
    Parameters(_lparen, params, optTrailingComma, _rparen) {
        if (params.source.contents === "" &&
            optTrailingComma.sourceString === ",") {
            (0, errors_2.throwSyntaxError)("Empty parameter list should not have a dangling comma.", createRef(optTrailingComma));
        }
        return params.asIteration().children.map((p) => p.astOfDeclaration());
    },
    Arguments(_lparen, args, optTrailingComma, _rparen) {
        if (args.source.contents === "" &&
            optTrailingComma.sourceString === ",") {
            (0, errors_2.throwSyntaxError)("Empty argument list should not have a dangling comma.", createRef(optTrailingComma));
        }
        return args.asIteration().children.map((arg) => arg.astOfExpression());
    },
});
semantics.addOperation("astOfContractAttributes", {
    ContractAttribute_interface(_interface, _lparen, interfaceName, _rparen) {
        return {
            type: "interface",
            name: interfaceName.astOfExpression(),
            loc: createRef(this),
        };
    },
});
semantics.addOperation("astOfDeclaration", {
    FieldDecl(id, _colon, type, _optAs, optStorageType, _optEq, optInitializer) {
        return (0, ast_1.createAstNode)({
            kind: "field_decl",
            name: id.astOfExpression(),
            type: type.astOfType(),
            as: unwrapOptNode(optStorageType, (t) => t.astOfExpression()),
            initializer: unwrapOptNode(optInitializer, (e) => e.astOfExpression()),
            loc: createRef(this),
        });
    },
    Parameter(id, _colon, type) {
        (0, checkVariableName_1.checkVariableName)(id.sourceString, createRef(id));
        return (0, ast_1.createAstNode)({
            kind: "typed_parameter",
            name: id.astOfExpression(),
            type: type.astOfType(),
            loc: createRef(this),
        });
    },
    StructFieldInitializer_full(fieldId, _colon, initializer) {
        return (0, ast_1.createAstNode)({
            kind: "struct_field_initializer",
            field: fieldId.astOfExpression(),
            initializer: initializer.astOfExpression(),
            loc: createRef(this),
        });
    },
    StructFieldInitializer_punned(fieldId) {
        return (0, ast_1.createAstNode)({
            kind: "struct_field_initializer",
            field: fieldId.astOfExpression(),
            initializer: fieldId.astOfExpression(),
            loc: createRef(this),
        });
    },
});
// Statements
semantics.addOperation("astOfStatement", {
    // TODO: process StatementBlock
    StatementLet(_letKwd, id, _optColon, optType, _equals, expression, _optSemicolonIfLastStmtInBlock) {
        (0, checkVariableName_1.checkVariableName)(id.sourceString, createRef(id));
        return (0, ast_1.createAstNode)({
            kind: "statement_let",
            name: id.astOfExpression(),
            type: unwrapOptNode(optType, (t) => t.astOfType()),
            expression: expression.astOfExpression(),
            loc: createRef(this),
        });
    },
    StatementReturn(_returnKwd, optExpression, _optSemicolonIfLastStmtInBlock) {
        return (0, ast_1.createAstNode)({
            kind: "statement_return",
            expression: unwrapOptNode(optExpression, (e) => e.astOfExpression()),
            loc: createRef(this),
        });
    },
    StatementExpression(expression, _optSemicolonIfLastStmtInBlock) {
        return (0, ast_1.createAstNode)({
            kind: "statement_expression",
            expression: expression.astOfExpression(),
            loc: createRef(this),
        });
    },
    StatementAssign(lvalue, operator, expression, _optSemicolonIfLastStmtInBlock) {
        if (operator.sourceString === "=") {
            return (0, ast_1.createAstNode)({
                kind: "statement_assign",
                path: lvalue.astOfExpression(),
                expression: expression.astOfExpression(),
                loc: createRef(this),
            });
        }
        else {
            let op;
            switch (operator.sourceString) {
                case "+=":
                    op = "+";
                    break;
                case "-=":
                    op = "-";
                    break;
                case "*=":
                    op = "*";
                    break;
                case "/=":
                    op = "/";
                    break;
                case "%=":
                    op = "%";
                    break;
                case "|=":
                    op = "|";
                    break;
                case "&=":
                    op = "&";
                    break;
                case "^=":
                    op = "^";
                    break;
                default:
                    (0, errors_1.throwInternalCompilerError)("Unreachable augmented assignment operator.");
            }
            return (0, ast_1.createAstNode)({
                kind: "statement_augmentedassign",
                path: lvalue.astOfExpression(),
                op,
                expression: expression.astOfExpression(),
                loc: createRef(this),
            });
        }
    },
    StatementCondition_noElse(_ifKwd, condition, _lbrace, thenBlock, _rbrace) {
        return (0, ast_1.createAstNode)({
            kind: "statement_condition",
            condition: condition.astOfExpression(),
            trueStatements: thenBlock.children.map((s) => s.astOfStatement()),
            falseStatements: null,
            elseif: null,
            loc: createRef(this),
        });
    },
    StatementCondition_withElse(_ifKwd, condition, _lbraceThen, thenBlock, _rbraceThen, _elseKwd, _lbraceElse, elseBlock, _rbraceElse) {
        return (0, ast_1.createAstNode)({
            kind: "statement_condition",
            condition: condition.astOfExpression(),
            trueStatements: thenBlock.children.map((s) => s.astOfStatement()),
            falseStatements: elseBlock.children.map((s) => s.astOfStatement()),
            elseif: null,
            loc: createRef(this),
        });
    },
    StatementCondition_withElseIf(_ifKwd, condition, _lbraceThen, thenBlock, _rbraceThen, _elseKwd, elseifClause) {
        return (0, ast_1.createAstNode)({
            kind: "statement_condition",
            condition: condition.astOfExpression(),
            trueStatements: thenBlock.children.map((s) => s.astOfStatement()),
            falseStatements: null,
            elseif: elseifClause.astOfStatement(),
            loc: createRef(this),
        });
    },
    StatementWhile(_whileKwd, _lparen, condition, _rparen, _lbrace, loopBody, _rbrace) {
        return (0, ast_1.createAstNode)({
            kind: "statement_while",
            condition: condition.astOfExpression(),
            statements: loopBody.children.map((s) => s.astOfStatement()),
            loc: createRef(this),
        });
    },
    StatementRepeat(_repeatKwd, _lparen, iterations, _rparen, _lbrace, loopBody, _rbrace) {
        return (0, ast_1.createAstNode)({
            kind: "statement_repeat",
            iterations: iterations.astOfExpression(),
            statements: loopBody.children.map((s) => s.astOfStatement()),
            loc: createRef(this),
        });
    },
    StatementUntil(_doKwd, _lbrace, loopBody, _rbrace, _untilKwd, _lparen, condition, _rparen, _optSemicolonIfLastStmtInBlock) {
        return (0, ast_1.createAstNode)({
            kind: "statement_until",
            condition: condition.astOfExpression(),
            statements: loopBody.children.map((s) => s.astOfStatement()),
            loc: createRef(this),
        });
    },
    StatementTry_noCatch(_tryKwd, _lbraceTry, tryBlock, _rbraceTry) {
        return (0, ast_1.createAstNode)({
            kind: "statement_try",
            statements: tryBlock.children.map((s) => s.astOfStatement()),
            loc: createRef(this),
        });
    },
    StatementTry_withCatch(_tryKwd, _lbraceTry, tryBlock, _rbraceTry, _catchKwd, _lparen, exitCodeId, _rparen, _lbraceCatch, catchBlock, _rbraceCatch) {
        return (0, ast_1.createAstNode)({
            kind: "statement_try_catch",
            statements: tryBlock.children.map((s) => s.astOfStatement()),
            catchName: exitCodeId.astOfExpression(),
            catchStatements: catchBlock.children.map((s) => s.astOfStatement()),
            loc: createRef(this),
        });
    },
    StatementForEach(_foreachKwd, _lparen, keyId, _comma, valueId, _inKwd, mapId, _rparen, _lbrace, foreachBlock, _rbrace) {
        (0, checkVariableName_1.checkVariableName)(keyId.sourceString, createRef(keyId));
        (0, checkVariableName_1.checkVariableName)(valueId.sourceString, createRef(valueId));
        return (0, ast_1.createAstNode)({
            kind: "statement_foreach",
            keyName: keyId.astOfExpression(),
            valueName: valueId.astOfExpression(),
            map: mapId.astOfExpression(),
            statements: foreachBlock.children.map((s) => s.astOfStatement()),
            loc: createRef(this),
        });
    },
});
semantics.addOperation("astOfType", {
    typeId(firstTactTypeIdCharacter, restOfTactTypeId) {
        return (0, ast_1.createAstNode)({
            kind: "type_id",
            text: firstTactTypeIdCharacter.sourceString +
                restOfTactTypeId.sourceString,
            loc: createRef(this),
        });
    },
    Type_optional(typeId, _questionMark) {
        return (0, ast_1.createAstNode)({
            kind: "optional_type",
            typeArg: typeId.astOfType(),
            loc: createRef(this),
        });
    },
    Type_regular(typeId) {
        return typeId.astOfType();
    },
    Type_map(_mapKwd, _langle, keyTypeId, _optAsKwdKey, optKeyStorageType, _comma, valueTypeId, _optAsKwdValue, optValueStorageType, _rangle) {
        return (0, ast_1.createAstNode)({
            kind: "map_type",
            keyType: keyTypeId.astOfType(),
            keyStorageType: unwrapOptNode(optKeyStorageType, (t) => t.astOfExpression()),
            valueType: valueTypeId.astOfType(),
            valueStorageType: unwrapOptNode(optValueStorageType, (t) => t.astOfExpression()),
            loc: createRef(this),
        });
    },
    Type_bounced(_bouncedKwd, _langle, typeId, _rangle) {
        return (0, ast_1.createAstNode)({
            kind: "bounced_message_type",
            messageType: typeId.astOfType(),
            loc: createRef(this),
        });
    },
});
// handles binary, octal, decimal and hexadecimal integer literals
function bigintOfIntLiteral(litString) {
    return BigInt(litString.sourceString.replaceAll("_", ""));
}
// Expressions
semantics.addOperation("astOfExpression", {
    // Literals
    integerLiteral(number) {
        return (0, ast_1.createAstNode)({
            kind: "number",
            value: bigintOfIntLiteral(number),
            loc: createRef(this),
        }); // Parses dec, hex, and bin numbers
    },
    boolLiteral(boolValue) {
        return (0, ast_1.createAstNode)({
            kind: "boolean",
            value: boolValue.sourceString === "true",
            loc: createRef(this),
        });
    },
    id(firstTactIdCharacter, restOfTactId) {
        return (0, ast_1.createAstNode)({
            kind: "id",
            text: firstTactIdCharacter.sourceString + restOfTactId.sourceString,
            loc: createRef(this),
        });
    },
    funcId(firstFuncIdCharacter, restOfFuncId) {
        return (0, ast_1.createAstNode)({
            kind: "func_id",
            text: firstFuncIdCharacter.sourceString + restOfFuncId.sourceString,
            loc: createRef(this),
        });
    },
    null(_nullKwd) {
        return (0, ast_1.createAstNode)({ kind: "null", loc: createRef(this) });
    },
    stringLiteral(_startQuotationMark, string, _endQuotationMark) {
        return (0, ast_1.createAstNode)({
            kind: "string",
            value: string.sourceString,
            loc: createRef(this),
        });
    },
    ExpressionAdd_add(left, _plus, right) {
        return (0, ast_1.createAstNode)({
            kind: "op_binary",
            op: "+",
            left: left.astOfExpression(),
            right: right.astOfExpression(),
            loc: createRef(this),
        });
    },
    ExpressionAdd_sub(left, _minus, right) {
        return (0, ast_1.createAstNode)({
            kind: "op_binary",
            op: "-",
            left: left.astOfExpression(),
            right: right.astOfExpression(),
            loc: createRef(this),
        });
    },
    ExpressionMul_div(left, _slash, right) {
        return (0, ast_1.createAstNode)({
            kind: "op_binary",
            op: "/",
            left: left.astOfExpression(),
            right: right.astOfExpression(),
            loc: createRef(this),
        });
    },
    ExpressionMul_mul(left, _star, right) {
        return (0, ast_1.createAstNode)({
            kind: "op_binary",
            op: "*",
            left: left.astOfExpression(),
            right: right.astOfExpression(),
            loc: createRef(this),
        });
    },
    ExpressionMul_rem(left, _percent, right) {
        return (0, ast_1.createAstNode)({
            kind: "op_binary",
            op: "%",
            left: left.astOfExpression(),
            right: right.astOfExpression(),
            loc: createRef(this),
        });
    },
    ExpressionEquality_eq(left, _equalsEquals, right) {
        return (0, ast_1.createAstNode)({
            kind: "op_binary",
            op: "==",
            left: left.astOfExpression(),
            right: right.astOfExpression(),
            loc: createRef(this),
        });
    },
    ExpressionEquality_not(left, _bangEquals, right) {
        return (0, ast_1.createAstNode)({
            kind: "op_binary",
            op: "!=",
            left: left.astOfExpression(),
            right: right.astOfExpression(),
            loc: createRef(this),
        });
    },
    ExpressionCompare_gt(left, _rangle, right) {
        return (0, ast_1.createAstNode)({
            kind: "op_binary",
            op: ">",
            left: left.astOfExpression(),
            right: right.astOfExpression(),
            loc: createRef(this),
        });
    },
    ExpressionCompare_gte(left, _rangleEquals, right) {
        return (0, ast_1.createAstNode)({
            kind: "op_binary",
            op: ">=",
            left: left.astOfExpression(),
            right: right.astOfExpression(),
            loc: createRef(this),
        });
    },
    ExpressionCompare_lt(left, _langle, right) {
        return (0, ast_1.createAstNode)({
            kind: "op_binary",
            op: "<",
            left: left.astOfExpression(),
            right: right.astOfExpression(),
            loc: createRef(this),
        });
    },
    ExpressionCompare_lte(left, _langleEquals, right) {
        return (0, ast_1.createAstNode)({
            kind: "op_binary",
            op: "<=",
            left: left.astOfExpression(),
            right: right.astOfExpression(),
            loc: createRef(this),
        });
    },
    ExpressionOr_or(left, _pipePipe, right) {
        return (0, ast_1.createAstNode)({
            kind: "op_binary",
            op: "||",
            left: left.astOfExpression(),
            right: right.astOfExpression(),
            loc: createRef(this),
        });
    },
    ExpressionAnd_and(left, _ampersandAmpersand, right) {
        return (0, ast_1.createAstNode)({
            kind: "op_binary",
            op: "&&",
            left: left.astOfExpression(),
            right: right.astOfExpression(),
            loc: createRef(this),
        });
    },
    ExpressionBitwiseShift_shr(left, _rangleRangle, right) {
        return (0, ast_1.createAstNode)({
            kind: "op_binary",
            op: ">>",
            left: left.astOfExpression(),
            right: right.astOfExpression(),
            loc: createRef(this),
        });
    },
    ExpressionBitwiseShift_shl(left, _langleLangle, right) {
        return (0, ast_1.createAstNode)({
            kind: "op_binary",
            op: "<<",
            left: left.astOfExpression(),
            right: right.astOfExpression(),
            loc: createRef(this),
        });
    },
    ExpressionBitwiseAnd_bitwiseAnd(left, _ampersand, right) {
        return (0, ast_1.createAstNode)({
            kind: "op_binary",
            op: "&",
            left: left.astOfExpression(),
            right: right.astOfExpression(),
            loc: createRef(this),
        });
    },
    ExpressionBitwiseOr_bitwiseOr(left, _pipe, right) {
        return (0, ast_1.createAstNode)({
            kind: "op_binary",
            op: "|",
            left: left.astOfExpression(),
            right: right.astOfExpression(),
            loc: createRef(this),
        });
    },
    ExpressionBitwiseXor_bitwiseXor(left, _caret, right) {
        return (0, ast_1.createAstNode)({
            kind: "op_binary",
            op: "^",
            left: left.astOfExpression(),
            right: right.astOfExpression(),
            loc: createRef(this),
        });
    },
    // Unary
    ExpressionUnary_plus(_plus, operand) {
        return (0, ast_1.createAstNode)({
            kind: "op_unary",
            op: "+",
            operand: operand.astOfExpression(),
            loc: createRef(this),
        });
    },
    ExpressionUnary_minus(_minus, operand) {
        return (0, ast_1.createAstNode)({
            kind: "op_unary",
            op: "-",
            operand: operand.astOfExpression(),
            loc: createRef(this),
        });
    },
    ExpressionUnary_not(_bang, operand) {
        return (0, ast_1.createAstNode)({
            kind: "op_unary",
            op: "!",
            operand: operand.astOfExpression(),
            loc: createRef(this),
        });
    },
    ExpressionUnary_bitwiseNot(_tilde, operand) {
        return (0, ast_1.createAstNode)({
            kind: "op_unary",
            op: "~",
            operand: operand.astOfExpression(),
            loc: createRef(this),
        });
    },
    ExpressionParens(_lparen, expression, _rparen) {
        return expression.astOfExpression();
    },
    ExpressionUnboxNotNull(operand, _bangBang) {
        return (0, ast_1.createAstNode)({
            kind: "op_unary",
            op: "!!",
            operand: operand.astOfExpression(),
            loc: createRef(this),
        });
    },
    ExpressionFieldAccess(source, _dot, fieldId) {
        return (0, ast_1.createAstNode)({
            kind: "field_access",
            aggregate: source.astOfExpression(),
            field: fieldId.astOfExpression(),
            loc: createRef(this),
        });
    },
    ExpressionMethodCall(source, _dot, methodId, methodArguments) {
        return (0, ast_1.createAstNode)({
            kind: "method_call",
            self: source.astOfExpression(),
            method: methodId.astOfExpression(),
            args: methodArguments.astsOfList(),
            loc: createRef(this),
        });
    },
    ExpressionStaticCall(functionId, functionArguments) {
        return (0, ast_1.createAstNode)({
            kind: "static_call",
            function: functionId.astOfExpression(),
            args: functionArguments.astsOfList(),
            loc: createRef(this),
        });
    },
    ExpressionStructInstance(typeId, _lbrace, structFields, optTrailingComma, _rbrace) {
        if (structFields.source.contents === "" &&
            optTrailingComma.sourceString === ",") {
            (0, errors_2.throwSyntaxError)("Empty parameter list should not have a dangling comma.", createRef(optTrailingComma));
        }
        return (0, ast_1.createAstNode)({
            kind: "struct_instance",
            type: typeId.astOfType(),
            args: structFields
                .asIteration()
                .children.map((d) => d.astOfDeclaration()),
            loc: createRef(this),
        });
    },
    ExpressionInitOf(_initOfKwd, contractId, initArguments) {
        return (0, ast_1.createAstNode)({
            kind: "init_of",
            contract: contractId.astOfExpression(),
            args: initArguments.astsOfList(),
            loc: createRef(this),
        });
    },
    // Ternary conditional
    ExpressionConditional_ternary(condition, _questionMark, thenExpression, _colon, elseExpression) {
        return (0, ast_1.createAstNode)({
            kind: "conditional",
            condition: condition.astOfExpression(),
            thenBranch: thenExpression.astOfExpression(),
            elseBranch: elseExpression.astOfExpression(),
            loc: createRef(this),
        });
    },
});
function parse(src, path, origin) {
    return inFile(path, () => {
        const matchResult = grammar_ohm_bundle_1.default.match(src);
        if (matchResult.failed()) {
            (0, errors_2.throwParseError)(matchResult, path, origin);
        }
        ctx = { origin };
        try {
            return semantics(matchResult).astOfModule();
        }
        finally {
            ctx = null;
        }
    });
}
exports.parse = parse;
function parseExpression(sourceCode) {
    const matchResult = grammar_ohm_bundle_1.default.match(sourceCode, "Expression");
    if (matchResult.failed()) {
        (0, errors_2.throwParseError)(matchResult, "", "user");
    }
    ctx = { origin: "user" };
    return semantics(matchResult).astOfExpression();
}
exports.parseExpression = parseExpression;
function parseImports(src, path, origin) {
    return inFile(path, () => {
        const matchResult = grammar_ohm_bundle_1.default.match(src, "JustImports");
        if (matchResult.failed()) {
            (0, errors_2.throwParseError)(matchResult, path, origin);
        }
        ctx = { origin };
        try {
            const imports = semantics(matchResult).astOfJustImports();
            return imports.map((imp) => imp.path.value);
        }
        finally {
            ctx = null;
        }
    });
}
exports.parseImports = parseImports;
