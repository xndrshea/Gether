"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseAndEvalExpression = exports.createNodeFileSystem = exports.run = void 0;
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const parseConfig_1 = require("./config/parseConfig");
const createNodeFileSystem_1 = require("./vfs/createNodeFileSystem");
const build_1 = require("./pipeline/build");
const logger_1 = require("./logger");
function configForSingleFile(fileName) {
    return {
        projects: [
            {
                name: path_1.default.basename(fileName, ".tact"),
                path: fileName,
                output: path_1.default.dirname(fileName),
                options: {
                    debug: true,
                    external: true,
                    ipfsAbiGetter: false,
                    interfacesGetter: false,
                },
                mode: "full",
            },
        ],
        rootPath: process.cwd(),
        singleFile: true,
    };
}
function loadConfig(fileName, configPath) {
    if (fileName)
        return configForSingleFile(fileName);
    if (!configPath)
        return null;
    let config;
    // Load config
    const resolvedPath = path_1.default.resolve(configPath);
    const rootPath = path_1.default.dirname(resolvedPath);
    if (!fs_1.default.existsSync(resolvedPath)) {
        console.warn("Unable to find config file at " + resolvedPath);
        return null;
    }
    try {
        config = (0, parseConfig_1.parseConfig)(fs_1.default.readFileSync(resolvedPath, "utf8"));
    }
    catch (e) {
        console.log(e);
        console.warn("Unable to parse config file at " + resolvedPath);
        return null;
    }
    return { singleFile: false, rootPath, ...config };
}
async function run(args) {
    const configWithRootPath = await loadConfig(args.fileName, args.configPath);
    if (!configWithRootPath) {
        return {
            ok: false,
            error: [
                new Error(`Unable to load config from path: ${args.configPath}`),
            ],
        };
    }
    const logger = new logger_1.Logger(args.suppressLog ? logger_1.LogLevel.NONE : logger_1.LogLevel.INFO);
    // Resolve projects
    let projects = configWithRootPath.projects;
    if (args.projectNames && args.projectNames.length > 0) {
        // Check that all project names are valid
        for (const pp of args.projectNames) {
            if (!projects.find((v) => v.name === pp)) {
                const message = "Unable to find project " + pp;
                logger.warn(message);
                return {
                    ok: false,
                    error: [new Error(message)],
                };
            }
        }
        // Filter by names
        projects = projects.filter((v) => args.projectNames.includes(v.name));
    }
    if (projects.length === 0) {
        const message = "No projects to compile";
        console.warn(message);
        return { ok: false, error: [new Error(message)] };
    }
    // Compile
    let success = true;
    let errorMessages = [];
    const project = (0, createNodeFileSystem_1.createNodeFileSystem)(configWithRootPath.rootPath, false);
    const stdlib = (0, createNodeFileSystem_1.createNodeFileSystem)(path_1.default.resolve(__dirname, "..", "stdlib"), false); // Improves developer experience
    for (const config of projects) {
        logger.info(`ðŸ’¼ Compiling project ${config.name} ...`);
        let cliConfig = { ...config };
        if (args.additionalCliOptions?.mode !== undefined) {
            cliConfig = { ...config, ...args.additionalCliOptions };
        }
        const built = await (0, build_1.build)({
            config: cliConfig,
            project,
            stdlib,
            logger,
        });
        success = success && built.ok;
        if (!built.ok && built.error.length > 0) {
            errorMessages = [...errorMessages, ...built.error];
        }
    }
    return { ok: success, error: errorMessages };
}
exports.run = run;
var createNodeFileSystem_2 = require("./vfs/createNodeFileSystem");
Object.defineProperty(exports, "createNodeFileSystem", { enumerable: true, get: function () { return createNodeFileSystem_2.createNodeFileSystem; } });
var interpreter_1 = require("./interpreter");
Object.defineProperty(exports, "parseAndEvalExpression", { enumerable: true, get: function () { return interpreter_1.parseAndEvalExpression; } });
