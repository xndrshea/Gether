{"ast":null,"code":"import { CONNECT_EVENT_ERROR_CODES, SEND_TRANSACTION_ERROR_CODES, Base64, SessionCrypto, hexToByteArray } from '@tonconnect/protocol';\nexport { CHAIN, CONNECT_EVENT_ERROR_CODES, CONNECT_ITEM_ERROR_CODES, SEND_TRANSACTION_ERROR_CODES } from '@tonconnect/protocol';\nimport '@tonconnect/isomorphic-eventsource';\nimport '@tonconnect/isomorphic-fetch';\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\nfunction __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\n/**\n * Base class for TonConnect errors. You can check if the error was triggered by the @tonconnect/sdk using `err instanceof TonConnectError`.\n */\nclass TonConnectError extends Error {\n  constructor(message, options) {\n    super(message, options);\n    this.message = `${TonConnectError.prefix} ${this.constructor.name}${this.info ? ': ' + this.info : ''}${message ? '\\n' + message : ''}`;\n    Object.setPrototypeOf(this, TonConnectError.prototype);\n  }\n  get info() {\n    return '';\n  }\n}\nTonConnectError.prefix = '[TON_CONNECT_SDK_ERROR]';\n\n/**\n * Thrown when passed DappMetadata is in incorrect format.\n */\nclass DappMetadataError extends TonConnectError {\n  get info() {\n    return 'Passed DappMetadata is in incorrect format.';\n  }\n  constructor(...args) {\n    super(...args);\n    Object.setPrototypeOf(this, DappMetadataError.prototype);\n  }\n}\n\n/**\n * Thrown when passed manifest contains errors.\n */\nclass ManifestContentErrorError extends TonConnectError {\n  get info() {\n    return 'Passed `tonconnect-manifest.json` contains errors. Check format of your manifest. See more https://github.com/ton-connect/docs/blob/main/requests-responses.md#app-manifest';\n  }\n  constructor(...args) {\n    super(...args);\n    Object.setPrototypeOf(this, ManifestContentErrorError.prototype);\n  }\n}\n\n/**\n * Thrown when wallet can't get manifest by passed manifestUrl.\n */\nclass ManifestNotFoundError extends TonConnectError {\n  get info() {\n    return 'Manifest not found. Make sure you added `tonconnect-manifest.json` to the root of your app or passed correct manifestUrl. See more https://github.com/ton-connect/docs/blob/main/requests-responses.md#app-manifest';\n  }\n  constructor(...args) {\n    super(...args);\n    Object.setPrototypeOf(this, ManifestNotFoundError.prototype);\n  }\n}\n\n/**\n * Thrown when wallet connection called but wallet already connected. To avoid the error, disconnect the wallet before doing a new connection.\n */\nclass WalletAlreadyConnectedError extends TonConnectError {\n  get info() {\n    return 'Wallet connection called but wallet already connected. To avoid the error, disconnect the wallet before doing a new connection.';\n  }\n  constructor(...args) {\n    super(...args);\n    Object.setPrototypeOf(this, WalletAlreadyConnectedError.prototype);\n  }\n}\n\n/**\n * Thrown when send transaction or other protocol methods called while wallet is not connected.\n */\nclass WalletNotConnectedError extends TonConnectError {\n  get info() {\n    return 'Send transaction or other protocol methods called while wallet is not connected.';\n  }\n  constructor(...args) {\n    super(...args);\n    Object.setPrototypeOf(this, WalletNotConnectedError.prototype);\n  }\n}\nfunction isWalletConnectionSourceJS(value) {\n  return 'jsBridgeKey' in value;\n}\n\n/**\n * Thrown when user rejects the action in the wallet.\n */\nclass UserRejectsError extends TonConnectError {\n  get info() {\n    return 'User rejects the action in the wallet.';\n  }\n  constructor(...args) {\n    super(...args);\n    Object.setPrototypeOf(this, UserRejectsError.prototype);\n  }\n}\n\n/**\n * Thrown when request to the wallet contains errors.\n */\nclass BadRequestError extends TonConnectError {\n  get info() {\n    return 'Request to the wallet contains errors.';\n  }\n  constructor(...args) {\n    super(...args);\n    Object.setPrototypeOf(this, BadRequestError.prototype);\n  }\n}\n\n/**\n * Thrown when app tries to send rpc request to the injected wallet while not connected.\n */\nclass UnknownAppError extends TonConnectError {\n  get info() {\n    return 'App tries to send rpc request to the injected wallet while not connected.';\n  }\n  constructor(...args) {\n    super(...args);\n    Object.setPrototypeOf(this, UnknownAppError.prototype);\n  }\n}\n\n/**\n * Thrown when there is an attempt to connect to the injected wallet while it is not exists in the webpage.\n */\nclass WalletNotInjectedError extends TonConnectError {\n  get info() {\n    return 'There is an attempt to connect to the injected wallet while it is not exists in the webpage.';\n  }\n  constructor(...args) {\n    super(...args);\n    Object.setPrototypeOf(this, WalletNotInjectedError.prototype);\n  }\n}\n\n/**\n * Thrown when `Storage` was not specified in the `DappMetadata` and default `localStorage` was not detected in the Node.js environment.\n */\nclass LocalstorageNotFoundError extends TonConnectError {\n  get info() {\n    return 'Storage was not specified in the `DappMetadata` and default `localStorage` was not detected in the environment.';\n  }\n  constructor(...args) {\n    super(...args);\n    Object.setPrototypeOf(this, LocalstorageNotFoundError.prototype);\n  }\n}\n\n/**\n * Thrown when an error occurred while fetching the wallets list.\n */\nclass FetchWalletsError extends TonConnectError {\n  get info() {\n    return 'An error occurred while fetching the wallets list.';\n  }\n  constructor(...args) {\n    super(...args);\n    Object.setPrototypeOf(this, FetchWalletsError.prototype);\n  }\n}\n\n/**\n * Thrown when passed address is in incorrect format.\n */\nclass WrongAddressError extends TonConnectError {\n  get info() {\n    return 'Passed address is in incorrect format.';\n  }\n  constructor(...args) {\n    super(...args);\n    Object.setPrototypeOf(this, WrongAddressError.prototype);\n  }\n}\n\n/**\n * Thrown when passed hex is in incorrect format.\n */\nclass ParseHexError extends TonConnectError {\n  get info() {\n    return 'Passed hex is in incorrect format.';\n  }\n  constructor(...args) {\n    super(...args);\n    Object.setPrototypeOf(this, ParseHexError.prototype);\n  }\n}\n\n/**\n * Unhanded unknown error.\n */\nclass UnknownError extends TonConnectError {\n  constructor(...args) {\n    super(...args);\n    Object.setPrototypeOf(this, UnknownError.prototype);\n  }\n}\nconst connectEventErrorsCodes = {\n  [CONNECT_EVENT_ERROR_CODES.UNKNOWN_ERROR]: UnknownError,\n  [CONNECT_EVENT_ERROR_CODES.USER_REJECTS_ERROR]: UserRejectsError,\n  [CONNECT_EVENT_ERROR_CODES.BAD_REQUEST_ERROR]: BadRequestError,\n  [CONNECT_EVENT_ERROR_CODES.UNKNOWN_APP_ERROR]: UnknownAppError,\n  [CONNECT_EVENT_ERROR_CODES.MANIFEST_NOT_FOUND_ERROR]: ManifestNotFoundError,\n  [CONNECT_EVENT_ERROR_CODES.MANIFEST_CONTENT_ERROR]: ManifestContentErrorError\n};\nclass ConnectErrorsParser {\n  parseError(error) {\n    let ErrorConstructor = UnknownError;\n    if (error.code in connectEventErrorsCodes) {\n      ErrorConstructor = connectEventErrorsCodes[error.code] || UnknownError;\n    }\n    return new ErrorConstructor(error.message);\n  }\n}\nconst connectErrorsParser = new ConnectErrorsParser();\nclass RpcParser {\n  isError(response) {\n    return 'error' in response;\n  }\n}\nconst sendTransactionErrors = {\n  [SEND_TRANSACTION_ERROR_CODES.UNKNOWN_ERROR]: UnknownError,\n  [SEND_TRANSACTION_ERROR_CODES.USER_REJECTS_ERROR]: UserRejectsError,\n  [SEND_TRANSACTION_ERROR_CODES.BAD_REQUEST_ERROR]: BadRequestError,\n  [SEND_TRANSACTION_ERROR_CODES.UNKNOWN_APP_ERROR]: UnknownAppError\n};\nclass SendTransactionParser extends RpcParser {\n  convertToRpcRequest(request) {\n    return {\n      method: 'sendTransaction',\n      params: [JSON.stringify(request)]\n    };\n  }\n  parseAndThrowError(response) {\n    let ErrorConstructor = UnknownError;\n    if (response.error.code in sendTransactionErrors) {\n      ErrorConstructor = sendTransactionErrors[response.error.code] || UnknownError;\n    }\n    throw new ErrorConstructor(response.error.message);\n  }\n  convertFromRpcResponse(rpcResponse) {\n    return {\n      boc: rpcResponse.result\n    };\n  }\n}\nconst sendTransactionParser = new SendTransactionParser();\nclass HttpBridgeGatewayStorage {\n  constructor(storage, bridgeUrl) {\n    this.storage = storage;\n    this.storeKey = 'ton-connect-storage_http-bridge-gateway::' + bridgeUrl;\n  }\n  storeLastEventId(lastEventId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.storage.setItem(this.storeKey, lastEventId);\n    });\n  }\n  removeLastEventId() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.storage.removeItem(this.storeKey);\n    });\n  }\n  getLastEventId() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const stored = yield this.storage.getItem(this.storeKey);\n      if (!stored) {\n        return null;\n      }\n      return stored;\n    });\n  }\n}\nfunction removeUrlLastSlash(url) {\n  if (url.slice(-1) === '/') {\n    return url.slice(0, -1);\n  }\n  return url;\n}\nfunction addPathToUrl(url, path) {\n  return removeUrlLastSlash(url) + '/' + path;\n}\nfunction isTelegramUrl(link) {\n  if (!link) {\n    return false;\n  }\n  const url = new URL(link);\n  return url.protocol === 'tg:' || url.hostname === 't.me';\n}\nfunction encodeTelegramUrlParameters(parameters) {\n  return parameters.replaceAll('.', '%2E').replaceAll('-', '%2D').replaceAll('_', '%5F').replaceAll('&', '-').replaceAll('=', '__').replaceAll('%', '--');\n}\n\n/**\n * Delays the execution of code for a specified number of milliseconds.\n * @param {number} timeout - The number of milliseconds to delay the execution.\n * @param {DelayOptions} [options] - Optional configuration options for the delay.\n * @return {Promise<void>} - A promise that resolves after the specified delay, or rejects if the delay is aborted.\n */\nfunction delay(timeout, options) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return new Promise((resolve, reject) => {\n      var _a, _b;\n      if ((_a = options === null || options === void 0 ? void 0 : options.signal) === null || _a === void 0 ? void 0 : _a.aborted) {\n        reject(new TonConnectError('Delay aborted'));\n        return;\n      }\n      const timeoutId = setTimeout(() => resolve(), timeout);\n      (_b = options === null || options === void 0 ? void 0 : options.signal) === null || _b === void 0 ? void 0 : _b.addEventListener('abort', () => {\n        clearTimeout(timeoutId);\n        reject(new TonConnectError('Delay aborted'));\n      });\n    });\n  });\n}\n\n/**\n * Creates an AbortController instance with an optional AbortSignal.\n *\n * @param {AbortSignal} [signal] - An optional AbortSignal to use for aborting the controller.\n * @returns {AbortController} - An instance of AbortController.\n */\nfunction createAbortController(signal) {\n  const abortController = new AbortController();\n  if (signal === null || signal === void 0 ? void 0 : signal.aborted) {\n    abortController.abort();\n  } else {\n    signal === null || signal === void 0 ? void 0 : signal.addEventListener('abort', () => abortController.abort(), {\n      once: true\n    });\n  }\n  return abortController;\n}\n\n/**\n * Function to call ton api until we get response.\n * Because ton network is pretty unstable we need to make sure response is final.\n * @param {T} fn - function to call\n * @param {CallForSuccessOptions} [options] - optional configuration options\n */\nfunction callForSuccess(fn, options) {\n  var _a, _b;\n  return __awaiter(this, void 0, void 0, function* () {\n    const attempts = (_a = options === null || options === void 0 ? void 0 : options.attempts) !== null && _a !== void 0 ? _a : 10;\n    const delayMs = (_b = options === null || options === void 0 ? void 0 : options.delayMs) !== null && _b !== void 0 ? _b : 200;\n    const abortController = createAbortController(options === null || options === void 0 ? void 0 : options.signal);\n    if (typeof fn !== 'function') {\n      throw new TonConnectError(`Expected a function, got ${typeof fn}`);\n    }\n    let i = 0;\n    let lastError;\n    while (i < attempts) {\n      if (abortController.signal.aborted) {\n        throw new TonConnectError(`Aborted after attempts ${i}`);\n      }\n      try {\n        return yield fn({\n          signal: abortController.signal\n        });\n      } catch (err) {\n        lastError = err;\n        i++;\n        if (i < attempts) {\n          yield delay(delayMs);\n        }\n      }\n    }\n    throw lastError;\n  });\n}\nfunction logDebug(...args) {\n  {\n    try {\n      console.debug('[TON_CONNECT_SDK]', ...args);\n    } catch (_a) {}\n  }\n}\nfunction logError(...args) {\n  {\n    try {\n      console.error('[TON_CONNECT_SDK]', ...args);\n    } catch (_a) {}\n  }\n}\nfunction logWarning(...args) {\n  {\n    try {\n      console.warn('[TON_CONNECT_SDK]', ...args);\n    } catch (_a) {}\n  }\n}\n\n/**\n * Create a resource.\n *\n * @template T - The type of the resource.\n * @template Args - The type of the arguments for creating the resource.\n *\n * @param {(...args: Args) => Promise<T>} createFn - A function that creates the resource.\n * @param {(resource: T) => Promise<void>} [disposeFn] - An optional function that disposes the resource.\n */\nfunction createResource(createFn, disposeFn) {\n  let currentResource = null;\n  let currentArgs = null;\n  let currentPromise = null;\n  let currentSignal = null;\n  let abortController = null;\n  // create a new resource\n  const create = (signal, ...args) => __awaiter(this, void 0, void 0, function* () {\n    currentSignal = signal !== null && signal !== void 0 ? signal : null;\n    abortController === null || abortController === void 0 ? void 0 : abortController.abort();\n    abortController = createAbortController(signal);\n    if (abortController.signal.aborted) {\n      throw new TonConnectError('Resource creation was aborted');\n    }\n    currentArgs = args !== null && args !== void 0 ? args : null;\n    const promise = createFn(abortController.signal, ...args);\n    currentPromise = promise;\n    const resource = yield promise;\n    if (currentPromise !== promise && resource !== currentResource) {\n      yield disposeFn(resource);\n      throw new TonConnectError('Resource creation was aborted by a new resource creation');\n    }\n    currentResource = resource;\n    return currentResource;\n  });\n  // get the current resource\n  const current = () => {\n    return currentResource !== null && currentResource !== void 0 ? currentResource : null;\n  };\n  // dispose the current resource\n  const dispose = () => __awaiter(this, void 0, void 0, function* () {\n    try {\n      const resource = currentResource;\n      currentResource = null;\n      const promise = currentPromise;\n      currentPromise = null;\n      try {\n        abortController === null || abortController === void 0 ? void 0 : abortController.abort();\n      } catch (e) {}\n      yield Promise.allSettled([resource ? disposeFn(resource) : Promise.resolve(), promise ? disposeFn(yield promise) : Promise.resolve()]);\n    } catch (e) {}\n  });\n  // recreate the current resource\n  const recreate = delayMs => __awaiter(this, void 0, void 0, function* () {\n    const resource = currentResource;\n    const promise = currentPromise;\n    const args = currentArgs;\n    const signal = currentSignal;\n    yield delay(delayMs);\n    if (resource === currentResource && promise === currentPromise && args === currentArgs && signal === currentSignal) {\n      return yield create(currentSignal, ...(args !== null && args !== void 0 ? args : []));\n    }\n    throw new TonConnectError('Resource recreation was aborted by a new resource creation');\n  });\n  return {\n    create,\n    current,\n    dispose,\n    recreate\n  };\n}\n\n/**\n * Executes a function and provides deferred behavior, allowing for a timeout and abort functionality.\n *\n * @param {Deferrable<T>} fn - The function to execute. It should return a promise that resolves with the desired result.\n * @param {DeferOptions} options - Optional configuration options for the defer behavior.\n * @returns {Promise<T>} - A promise that resolves with the result of the executed function, or rejects with an error if it times out or is aborted.\n */\nfunction timeout(fn, options) {\n  const timeout = options === null || options === void 0 ? void 0 : options.timeout;\n  const signal = options === null || options === void 0 ? void 0 : options.signal;\n  const abortController = createAbortController(signal);\n  return new Promise((resolve, reject) => {\n    if (abortController.signal.aborted) {\n      reject(new TonConnectError('Operation aborted'));\n      return;\n    }\n    let timeoutId;\n    if (typeof timeout !== 'undefined') {\n      timeoutId = setTimeout(() => {\n        abortController.abort();\n        reject(new TonConnectError(`Timeout after ${timeout}ms`));\n      }, timeout);\n    }\n    abortController.signal.addEventListener('abort', () => {\n      clearTimeout(timeoutId);\n      reject(new TonConnectError('Operation aborted'));\n    }, {\n      once: true\n    });\n    const deferOptions = {\n      timeout,\n      abort: abortController.signal\n    };\n    fn(resolve, reject, deferOptions).finally(() => clearTimeout(timeoutId));\n  });\n}\nclass BridgeGateway {\n  constructor(storage, bridgeUrl, sessionId, listener, errorsListener) {\n    this.bridgeUrl = bridgeUrl;\n    this.sessionId = sessionId;\n    this.listener = listener;\n    this.errorsListener = errorsListener;\n    this.ssePath = 'events';\n    this.postPath = 'message';\n    this.heartbeatMessage = 'heartbeat';\n    this.defaultTtl = 300;\n    this.defaultReconnectDelay = 5000;\n    this.eventSource = createResource((signal, openingDeadlineMS) => __awaiter(this, void 0, void 0, function* () {\n      const eventSourceConfig = {\n        bridgeUrl: this.bridgeUrl,\n        ssePath: this.ssePath,\n        sessionId: this.sessionId,\n        bridgeGatewayStorage: this.bridgeGatewayStorage,\n        errorHandler: this.errorsHandler.bind(this),\n        messageHandler: this.messagesHandler.bind(this),\n        signal: signal,\n        openingDeadlineMS: openingDeadlineMS\n      };\n      return yield createEventSource(eventSourceConfig);\n    }), resource => __awaiter(this, void 0, void 0, function* () {\n      resource.close();\n    }));\n    this.bridgeGatewayStorage = new HttpBridgeGatewayStorage(storage, bridgeUrl);\n  }\n  get isReady() {\n    const eventSource = this.eventSource.current();\n    return (eventSource === null || eventSource === void 0 ? void 0 : eventSource.readyState) === EventSource.OPEN;\n  }\n  get isClosed() {\n    const eventSource = this.eventSource.current();\n    return (eventSource === null || eventSource === void 0 ? void 0 : eventSource.readyState) !== EventSource.OPEN;\n  }\n  get isConnecting() {\n    const eventSource = this.eventSource.current();\n    return (eventSource === null || eventSource === void 0 ? void 0 : eventSource.readyState) === EventSource.CONNECTING;\n  }\n  registerSession(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.eventSource.create(options === null || options === void 0 ? void 0 : options.signal, options === null || options === void 0 ? void 0 : options.openingDeadlineMS);\n    });\n  }\n  send(message, receiver, topic, ttlOrOptions) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      // TODO: remove deprecated method\n      const options = {};\n      if (typeof ttlOrOptions === 'number') {\n        options.ttl = ttlOrOptions;\n      } else {\n        options.ttl = ttlOrOptions === null || ttlOrOptions === void 0 ? void 0 : ttlOrOptions.ttl;\n        options.signal = ttlOrOptions === null || ttlOrOptions === void 0 ? void 0 : ttlOrOptions.signal;\n        options.attempts = ttlOrOptions === null || ttlOrOptions === void 0 ? void 0 : ttlOrOptions.attempts;\n      }\n      const url = new URL(addPathToUrl(this.bridgeUrl, this.postPath));\n      url.searchParams.append('client_id', this.sessionId);\n      url.searchParams.append('to', receiver);\n      url.searchParams.append('ttl', ((options === null || options === void 0 ? void 0 : options.ttl) || this.defaultTtl).toString());\n      url.searchParams.append('topic', topic);\n      const body = Base64.encode(message);\n      yield callForSuccess(options => __awaiter(this, void 0, void 0, function* () {\n        const response = yield this.post(url, body, options.signal);\n        if (!response.ok) {\n          throw new TonConnectError(`Bridge send failed, status ${response.status}`);\n        }\n      }), {\n        attempts: (_a = options === null || options === void 0 ? void 0 : options.attempts) !== null && _a !== void 0 ? _a : Number.MAX_SAFE_INTEGER,\n        delayMs: 5000,\n        signal: options === null || options === void 0 ? void 0 : options.signal\n      });\n    });\n  }\n  pause() {\n    this.eventSource.dispose().catch(e => logError(`Bridge pause failed, ${e}`));\n  }\n  unPause() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const RECREATE_WITHOUT_DELAY = 0;\n      yield this.eventSource.recreate(RECREATE_WITHOUT_DELAY);\n    });\n  }\n  close() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.eventSource.dispose().catch(e => logError(`Bridge close failed, ${e}`));\n    });\n  }\n  setListener(listener) {\n    this.listener = listener;\n  }\n  setErrorsListener(errorsListener) {\n    this.errorsListener = errorsListener;\n  }\n  post(url, body, signal) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const response = yield fetch(url, {\n        method: 'post',\n        body: body,\n        signal: signal\n      });\n      if (!response.ok) {\n        throw new TonConnectError(`Bridge send failed, status ${response.status}`);\n      }\n      return response;\n    });\n  }\n  errorsHandler(eventSource, e) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.isConnecting) {\n        logError('Bridge error', JSON.stringify(e));\n        return;\n      }\n      if (this.isReady) {\n        try {\n          this.errorsListener(e);\n        } catch (e) {}\n        return;\n      }\n      if (this.isClosed) {\n        eventSource.close();\n        logDebug(`Bridge reconnecting, ${this.defaultReconnectDelay}ms delay`);\n        return yield this.eventSource.recreate(this.defaultReconnectDelay);\n      }\n      throw new TonConnectError('Bridge error, unknown state');\n    });\n  }\n  messagesHandler(e) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (e.data === this.heartbeatMessage) {\n        return;\n      }\n      yield this.bridgeGatewayStorage.storeLastEventId(e.lastEventId);\n      if (this.isClosed) {\n        return;\n      }\n      let bridgeIncomingMessage;\n      try {\n        bridgeIncomingMessage = JSON.parse(e.data);\n      } catch (e) {\n        throw new TonConnectError(`Bridge message parse failed, message ${e.data}`);\n      }\n      this.listener(bridgeIncomingMessage);\n    });\n  }\n}\n/**\n * Creates an event source.\n * @param {CreateEventSourceConfig} config - Configuration for creating an event source.\n */\nfunction createEventSource(config) {\n  return __awaiter(this, void 0, void 0, function* () {\n    return yield timeout((resolve, reject, deferOptions) => __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      const abortController = createAbortController(deferOptions.signal);\n      const signal = abortController.signal;\n      if (signal.aborted) {\n        reject(new TonConnectError('Bridge connection aborted'));\n        return;\n      }\n      const url = new URL(addPathToUrl(config.bridgeUrl, config.ssePath));\n      url.searchParams.append('client_id', config.sessionId);\n      const lastEventId = yield config.bridgeGatewayStorage.getLastEventId();\n      if (lastEventId) {\n        url.searchParams.append('last_event_id', lastEventId);\n      }\n      if (signal.aborted) {\n        reject(new TonConnectError('Bridge connection aborted'));\n        return;\n      }\n      const eventSource = new EventSource(url.toString());\n      eventSource.onerror = reason => __awaiter(this, void 0, void 0, function* () {\n        if (signal.aborted) {\n          eventSource.close();\n          reject(new TonConnectError('Bridge connection aborted'));\n          return;\n        }\n        try {\n          const newInstance = yield config.errorHandler(eventSource, reason);\n          if (newInstance !== eventSource) {\n            eventSource.close();\n          }\n          if (newInstance && newInstance !== eventSource) {\n            resolve(newInstance);\n          }\n        } catch (e) {\n          eventSource.close();\n          reject(e);\n        }\n      });\n      eventSource.onopen = () => {\n        if (signal.aborted) {\n          eventSource.close();\n          reject(new TonConnectError('Bridge connection aborted'));\n          return;\n        }\n        resolve(eventSource);\n      };\n      eventSource.onmessage = event => {\n        if (signal.aborted) {\n          eventSource.close();\n          reject(new TonConnectError('Bridge connection aborted'));\n          return;\n        }\n        config.messageHandler(event);\n      };\n      (_a = config.signal) === null || _a === void 0 ? void 0 : _a.addEventListener('abort', () => {\n        eventSource.close();\n        reject(new TonConnectError('Bridge connection aborted'));\n      });\n    }), {\n      timeout: config.openingDeadlineMS,\n      signal: config.signal\n    });\n  });\n}\nfunction isPendingConnectionHttp(connection) {\n  return !('connectEvent' in connection);\n}\nclass BridgeConnectionStorage {\n  constructor(storage) {\n    this.storage = storage;\n    this.storeKey = 'ton-connect-storage_bridge-connection';\n  }\n  storeConnection(connection) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (connection.type === 'injected') {\n        return this.storage.setItem(this.storeKey, JSON.stringify(connection));\n      }\n      if (!isPendingConnectionHttp(connection)) {\n        const rawSession = {\n          sessionKeyPair: connection.session.sessionCrypto.stringifyKeypair(),\n          walletPublicKey: connection.session.walletPublicKey,\n          bridgeUrl: connection.session.bridgeUrl\n        };\n        const rawConnection = {\n          type: 'http',\n          connectEvent: connection.connectEvent,\n          session: rawSession,\n          lastWalletEventId: connection.lastWalletEventId,\n          nextRpcRequestId: connection.nextRpcRequestId\n        };\n        return this.storage.setItem(this.storeKey, JSON.stringify(rawConnection));\n      }\n      const rawConnection = {\n        type: 'http',\n        connectionSource: connection.connectionSource,\n        sessionCrypto: connection.sessionCrypto.stringifyKeypair()\n      };\n      return this.storage.setItem(this.storeKey, JSON.stringify(rawConnection));\n    });\n  }\n  removeConnection() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.storage.removeItem(this.storeKey);\n    });\n  }\n  getConnection() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const stored = yield this.storage.getItem(this.storeKey);\n      if (!stored) {\n        return null;\n      }\n      const connection = JSON.parse(stored);\n      if (connection.type === 'injected') {\n        return connection;\n      }\n      if ('connectEvent' in connection) {\n        const sessionCrypto = new SessionCrypto(connection.session.sessionKeyPair);\n        return {\n          type: 'http',\n          connectEvent: connection.connectEvent,\n          lastWalletEventId: connection.lastWalletEventId,\n          nextRpcRequestId: connection.nextRpcRequestId,\n          session: {\n            sessionCrypto,\n            bridgeUrl: connection.session.bridgeUrl,\n            walletPublicKey: connection.session.walletPublicKey\n          }\n        };\n      }\n      return {\n        type: 'http',\n        sessionCrypto: new SessionCrypto(connection.sessionCrypto),\n        connectionSource: connection.connectionSource\n      };\n    });\n  }\n  getHttpConnection() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const connection = yield this.getConnection();\n      if (!connection) {\n        throw new TonConnectError('Trying to read HTTP connection source while nothing is stored');\n      }\n      if (connection.type === 'injected') {\n        throw new TonConnectError('Trying to read HTTP connection source while injected connection is stored');\n      }\n      return connection;\n    });\n  }\n  getHttpPendingConnection() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const connection = yield this.getConnection();\n      if (!connection) {\n        throw new TonConnectError('Trying to read HTTP connection source while nothing is stored');\n      }\n      if (connection.type === 'injected') {\n        throw new TonConnectError('Trying to read HTTP connection source while injected connection is stored');\n      }\n      if (!isPendingConnectionHttp(connection)) {\n        throw new TonConnectError('Trying to read HTTP-pending connection while http connection is stored');\n      }\n      return connection;\n    });\n  }\n  getInjectedConnection() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const connection = yield this.getConnection();\n      if (!connection) {\n        throw new TonConnectError('Trying to read Injected bridge connection source while nothing is stored');\n      }\n      if ((connection === null || connection === void 0 ? void 0 : connection.type) === 'http') {\n        throw new TonConnectError('Trying to read Injected bridge connection source while HTTP connection is stored');\n      }\n      return connection;\n    });\n  }\n  storedConnectionType() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const stored = yield this.storage.getItem(this.storeKey);\n      if (!stored) {\n        return null;\n      }\n      const connection = JSON.parse(stored);\n      return connection.type;\n    });\n  }\n  storeLastWalletEventId(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const connection = yield this.getConnection();\n      if (connection && connection.type === 'http' && !isPendingConnectionHttp(connection)) {\n        connection.lastWalletEventId = id;\n        return this.storeConnection(connection);\n      }\n    });\n  }\n  getLastWalletEventId() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const connection = yield this.getConnection();\n      if (connection && 'lastWalletEventId' in connection) {\n        return connection.lastWalletEventId;\n      }\n      return undefined;\n    });\n  }\n  increaseNextRpcRequestId() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const connection = yield this.getConnection();\n      if (connection && 'nextRpcRequestId' in connection) {\n        const lastId = connection.nextRpcRequestId || 0;\n        connection.nextRpcRequestId = lastId + 1;\n        return this.storeConnection(connection);\n      }\n    });\n  }\n  getNextRpcRequestId() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const connection = yield this.getConnection();\n      if (connection && 'nextRpcRequestId' in connection) {\n        return connection.nextRpcRequestId || 0;\n      }\n      return 0;\n    });\n  }\n}\nconst PROTOCOL_VERSION = 2;\nclass BridgeProvider {\n  constructor(storage, walletConnectionSource) {\n    this.storage = storage;\n    this.walletConnectionSource = walletConnectionSource;\n    this.type = 'http';\n    this.standardUniversalLink = 'tc://';\n    this.pendingRequests = new Map();\n    this.session = null;\n    this.gateway = null;\n    this.pendingGateways = [];\n    this.listeners = [];\n    this.defaultOpeningDeadlineMS = 5000;\n    this.connectionStorage = new BridgeConnectionStorage(storage);\n  }\n  static fromStorage(storage) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const bridgeConnectionStorage = new BridgeConnectionStorage(storage);\n      const connection = yield bridgeConnectionStorage.getHttpConnection();\n      if (isPendingConnectionHttp(connection)) {\n        return new BridgeProvider(storage, connection.connectionSource);\n      }\n      return new BridgeProvider(storage, {\n        bridgeUrl: connection.session.bridgeUrl\n      });\n    });\n  }\n  connect(message, options) {\n    var _a;\n    const abortController = createAbortController(options === null || options === void 0 ? void 0 : options.signal);\n    (_a = this.abortController) === null || _a === void 0 ? void 0 : _a.abort();\n    this.abortController = abortController;\n    this.closeGateways();\n    const sessionCrypto = new SessionCrypto();\n    this.session = {\n      sessionCrypto,\n      bridgeUrl: 'bridgeUrl' in this.walletConnectionSource ? this.walletConnectionSource.bridgeUrl : ''\n    };\n    this.connectionStorage.storeConnection({\n      type: 'http',\n      connectionSource: this.walletConnectionSource,\n      sessionCrypto\n    }).then(() => __awaiter(this, void 0, void 0, function* () {\n      if (abortController.signal.aborted) {\n        return;\n      }\n      yield callForSuccess(_options => this.openGateways(sessionCrypto, {\n        openingDeadlineMS: options === null || options === void 0 ? void 0 : options.openingDeadlineMS,\n        signal: _options === null || _options === void 0 ? void 0 : _options.signal\n      }), {\n        attempts: Number.MAX_SAFE_INTEGER,\n        delayMs: 5000,\n        signal: abortController.signal\n      });\n    }));\n    const universalLink = 'universalLink' in this.walletConnectionSource && this.walletConnectionSource.universalLink ? this.walletConnectionSource.universalLink : this.standardUniversalLink;\n    return this.generateUniversalLink(universalLink, message);\n  }\n  restoreConnection(options) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      const abortController = createAbortController(options === null || options === void 0 ? void 0 : options.signal);\n      (_a = this.abortController) === null || _a === void 0 ? void 0 : _a.abort();\n      this.abortController = abortController;\n      if (abortController.signal.aborted) {\n        return;\n      }\n      this.closeGateways();\n      const storedConnection = yield this.connectionStorage.getHttpConnection();\n      if (!storedConnection) {\n        return;\n      }\n      if (abortController.signal.aborted) {\n        return;\n      }\n      const openingDeadlineMS = (_b = options === null || options === void 0 ? void 0 : options.openingDeadlineMS) !== null && _b !== void 0 ? _b : this.defaultOpeningDeadlineMS;\n      if (isPendingConnectionHttp(storedConnection)) {\n        this.session = {\n          sessionCrypto: storedConnection.sessionCrypto,\n          bridgeUrl: 'bridgeUrl' in this.walletConnectionSource ? this.walletConnectionSource.bridgeUrl : ''\n        };\n        return yield this.openGateways(storedConnection.sessionCrypto, {\n          openingDeadlineMS: openingDeadlineMS,\n          signal: abortController === null || abortController === void 0 ? void 0 : abortController.signal\n        });\n      }\n      if (Array.isArray(this.walletConnectionSource)) {\n        throw new TonConnectError('Internal error. Connection source is array while WalletConnectionSourceHTTP was expected.');\n      }\n      this.session = storedConnection.session;\n      if (this.gateway) {\n        logDebug('Gateway is already opened, closing previous gateway');\n        yield this.gateway.close();\n      }\n      this.gateway = new BridgeGateway(this.storage, this.walletConnectionSource.bridgeUrl, storedConnection.session.sessionCrypto.sessionId, this.gatewayListener.bind(this), this.gatewayErrorsListener.bind(this));\n      if (abortController.signal.aborted) {\n        return;\n      }\n      // notify listeners about stored connection\n      this.listeners.forEach(listener => listener(storedConnection.connectEvent));\n      // wait for the connection to be opened\n      try {\n        yield callForSuccess(options => this.gateway.registerSession({\n          openingDeadlineMS: openingDeadlineMS,\n          signal: options.signal\n        }), {\n          attempts: Number.MAX_SAFE_INTEGER,\n          delayMs: 5000,\n          signal: abortController.signal\n        });\n      } catch (e) {\n        yield this.disconnect({\n          signal: abortController.signal\n        });\n        return;\n      }\n    });\n  }\n  sendRequest(request, optionsOrOnRequestSent) {\n    // TODO: remove deprecated method\n    const options = {};\n    if (typeof optionsOrOnRequestSent === 'function') {\n      options.onRequestSent = optionsOrOnRequestSent;\n    } else {\n      options.onRequestSent = optionsOrOnRequestSent === null || optionsOrOnRequestSent === void 0 ? void 0 : optionsOrOnRequestSent.onRequestSent;\n      options.signal = optionsOrOnRequestSent === null || optionsOrOnRequestSent === void 0 ? void 0 : optionsOrOnRequestSent.signal;\n      options.attempts = optionsOrOnRequestSent === null || optionsOrOnRequestSent === void 0 ? void 0 : optionsOrOnRequestSent.attempts;\n    }\n    return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n      var _a;\n      if (!this.gateway || !this.session || !('walletPublicKey' in this.session)) {\n        throw new TonConnectError('Trying to send bridge request without session');\n      }\n      const id = (yield this.connectionStorage.getNextRpcRequestId()).toString();\n      yield this.connectionStorage.increaseNextRpcRequestId();\n      logDebug('Send http-bridge request:', Object.assign(Object.assign({}, request), {\n        id\n      }));\n      const encodedRequest = this.session.sessionCrypto.encrypt(JSON.stringify(Object.assign(Object.assign({}, request), {\n        id\n      })), hexToByteArray(this.session.walletPublicKey));\n      try {\n        yield this.gateway.send(encodedRequest, this.session.walletPublicKey, request.method, {\n          attempts: options === null || options === void 0 ? void 0 : options.attempts,\n          signal: options === null || options === void 0 ? void 0 : options.signal\n        });\n        (_a = options === null || options === void 0 ? void 0 : options.onRequestSent) === null || _a === void 0 ? void 0 : _a.call(options);\n        this.pendingRequests.set(id.toString(), resolve);\n      } catch (e) {\n        reject(e);\n      }\n    }));\n  }\n  closeConnection() {\n    this.closeGateways();\n    this.listeners = [];\n    this.session = null;\n    this.gateway = null;\n  }\n  disconnect(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return new Promise(resolve => __awaiter(this, void 0, void 0, function* () {\n        let called = false;\n        let timeoutId = null;\n        const onRequestSent = () => {\n          if (!called) {\n            called = true;\n            this.removeBridgeAndSession().then(resolve);\n          }\n        };\n        try {\n          this.closeGateways();\n          const abortController = createAbortController(options === null || options === void 0 ? void 0 : options.signal);\n          timeoutId = setTimeout(() => {\n            abortController.abort();\n          }, this.defaultOpeningDeadlineMS);\n          yield this.sendRequest({\n            method: 'disconnect',\n            params: []\n          }, {\n            onRequestSent: onRequestSent,\n            signal: abortController.signal,\n            attempts: 1\n          });\n        } catch (e) {\n          logDebug('Disconnect error:', e);\n          if (!called) {\n            this.removeBridgeAndSession().then(resolve);\n          }\n        } finally {\n          if (timeoutId) {\n            clearTimeout(timeoutId);\n          }\n          onRequestSent();\n        }\n      }));\n    });\n  }\n  listen(callback) {\n    this.listeners.push(callback);\n    return () => this.listeners = this.listeners.filter(listener => listener !== callback);\n  }\n  pause() {\n    var _a;\n    (_a = this.gateway) === null || _a === void 0 ? void 0 : _a.pause();\n    this.pendingGateways.forEach(bridge => bridge.pause());\n  }\n  unPause() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const promises = this.pendingGateways.map(bridge => bridge.unPause());\n      if (this.gateway) {\n        promises.push(this.gateway.unPause());\n      }\n      yield Promise.all(promises);\n    });\n  }\n  pendingGatewaysListener(gateway, bridgeUrl, bridgeIncomingMessage) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.pendingGateways.includes(gateway)) {\n        yield gateway.close();\n        return;\n      }\n      this.closeGateways({\n        except: gateway\n      });\n      if (this.gateway) {\n        logDebug('Gateway is already opened, closing previous gateway');\n        yield this.gateway.close();\n      }\n      this.session.bridgeUrl = bridgeUrl;\n      this.gateway = gateway;\n      this.gateway.setErrorsListener(this.gatewayErrorsListener.bind(this));\n      this.gateway.setListener(this.gatewayListener.bind(this));\n      return this.gatewayListener(bridgeIncomingMessage);\n    });\n  }\n  gatewayListener(bridgeIncomingMessage) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const walletMessage = JSON.parse(this.session.sessionCrypto.decrypt(Base64.decode(bridgeIncomingMessage.message).toUint8Array(), hexToByteArray(bridgeIncomingMessage.from)));\n      logDebug('Wallet message received:', walletMessage);\n      if (!('event' in walletMessage)) {\n        const id = walletMessage.id.toString();\n        const resolve = this.pendingRequests.get(id);\n        if (!resolve) {\n          logDebug(`Response id ${id} doesn't match any request's id`);\n          return;\n        }\n        resolve(walletMessage);\n        this.pendingRequests.delete(id);\n        return;\n      }\n      if (walletMessage.id !== undefined) {\n        const lastId = yield this.connectionStorage.getLastWalletEventId();\n        if (lastId !== undefined && walletMessage.id <= lastId) {\n          logError(`Received event id (=${walletMessage.id}) must be greater than stored last wallet event id (=${lastId}) `);\n          return;\n        }\n        if (walletMessage.event !== 'connect') {\n          yield this.connectionStorage.storeLastWalletEventId(walletMessage.id);\n        }\n      }\n      // `this.listeners` might be modified in the event handler\n      const listeners = this.listeners;\n      if (walletMessage.event === 'connect') {\n        yield this.updateSession(walletMessage, bridgeIncomingMessage.from);\n      }\n      if (walletMessage.event === 'disconnect') {\n        logDebug(`Removing bridge and session: received disconnect event`);\n        yield this.removeBridgeAndSession();\n      }\n      listeners.forEach(listener => listener(walletMessage));\n    });\n  }\n  gatewayErrorsListener(e) {\n    return __awaiter(this, void 0, void 0, function* () {\n      throw new TonConnectError(`Bridge error ${JSON.stringify(e)}`);\n    });\n  }\n  updateSession(connectEvent, walletPublicKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.session = Object.assign(Object.assign({}, this.session), {\n        walletPublicKey\n      });\n      const tonAddrItem = connectEvent.payload.items.find(item => item.name === 'ton_addr');\n      const connectEventToSave = Object.assign(Object.assign({}, connectEvent), {\n        payload: Object.assign(Object.assign({}, connectEvent.payload), {\n          items: [tonAddrItem]\n        })\n      });\n      yield this.connectionStorage.storeConnection({\n        type: 'http',\n        session: this.session,\n        lastWalletEventId: connectEvent.id,\n        connectEvent: connectEventToSave,\n        nextRpcRequestId: 0\n      });\n    });\n  }\n  removeBridgeAndSession() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.closeConnection();\n      yield this.connectionStorage.removeConnection();\n    });\n  }\n  generateUniversalLink(universalLink, message) {\n    if (isTelegramUrl(universalLink)) {\n      return this.generateTGUniversalLink(universalLink, message);\n    }\n    return this.generateRegularUniversalLink(universalLink, message);\n  }\n  generateRegularUniversalLink(universalLink, message) {\n    const url = new URL(universalLink);\n    url.searchParams.append('v', PROTOCOL_VERSION.toString());\n    url.searchParams.append('id', this.session.sessionCrypto.sessionId);\n    url.searchParams.append('r', JSON.stringify(message));\n    return url.toString();\n  }\n  generateTGUniversalLink(universalLink, message) {\n    const urlToWrap = this.generateRegularUniversalLink('about:blank', message);\n    const linkParams = urlToWrap.split('?')[1];\n    const startapp = 'tonconnect-' + encodeTelegramUrlParameters(linkParams);\n    // TODO: Remove this line after all dApps and the wallets-list.json have been updated\n    const updatedUniversalLink = this.convertToDirectLink(universalLink);\n    const url = new URL(updatedUniversalLink);\n    url.searchParams.append('startapp', startapp);\n    return url.toString();\n  }\n  // TODO: Remove this method after all dApps and the wallets-list.json have been updated\n  convertToDirectLink(universalLink) {\n    const url = new URL(universalLink);\n    if (url.searchParams.has('attach')) {\n      url.searchParams.delete('attach');\n      url.pathname += '/start';\n    }\n    return url.toString();\n  }\n  openGateways(sessionCrypto, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (Array.isArray(this.walletConnectionSource)) {\n        // close all gateways before opening new ones\n        this.pendingGateways.map(bridge => bridge.close().catch());\n        // open new gateways\n        this.pendingGateways = this.walletConnectionSource.map(source => {\n          const gateway = new BridgeGateway(this.storage, source.bridgeUrl, sessionCrypto.sessionId, () => {}, () => {});\n          gateway.setListener(message => this.pendingGatewaysListener(gateway, source.bridgeUrl, message));\n          return gateway;\n        });\n        yield Promise.allSettled(this.pendingGateways.map(bridge => callForSuccess(_options => {\n          if (!this.pendingGateways.some(item => item === bridge)) {\n            return bridge.close();\n          }\n          return bridge.registerSession({\n            openingDeadlineMS: options === null || options === void 0 ? void 0 : options.openingDeadlineMS,\n            signal: _options.signal\n          });\n        }, {\n          attempts: Number.MAX_SAFE_INTEGER,\n          delayMs: 5000,\n          signal: options === null || options === void 0 ? void 0 : options.signal\n        })));\n        return;\n      } else {\n        if (this.gateway) {\n          logDebug(`Gateway is already opened, closing previous gateway`);\n          yield this.gateway.close();\n        }\n        this.gateway = new BridgeGateway(this.storage, this.walletConnectionSource.bridgeUrl, sessionCrypto.sessionId, this.gatewayListener.bind(this), this.gatewayErrorsListener.bind(this));\n        return yield this.gateway.registerSession({\n          openingDeadlineMS: options === null || options === void 0 ? void 0 : options.openingDeadlineMS,\n          signal: options === null || options === void 0 ? void 0 : options.signal\n        });\n      }\n    });\n  }\n  closeGateways(options) {\n    var _a;\n    (_a = this.gateway) === null || _a === void 0 ? void 0 : _a.close();\n    this.pendingGateways.filter(item => item !== (options === null || options === void 0 ? void 0 : options.except)).forEach(bridge => bridge.close());\n    this.pendingGateways = [];\n  }\n}\nfunction hasProperty(value, propertyKey) {\n  return hasProperties(value, [propertyKey]);\n}\nfunction hasProperties(value, propertyKeys) {\n  if (!value || typeof value !== 'object') {\n    return false;\n  }\n  return propertyKeys.every(propertyKey => propertyKey in value);\n}\nfunction isJSBridgeWithMetadata(value) {\n  try {\n    if (!hasProperty(value, 'tonconnect') || !hasProperty(value.tonconnect, 'walletInfo')) {\n      return false;\n    }\n    return hasProperties(value.tonconnect.walletInfo, ['name', 'app_name', 'image', 'about_url', 'platforms']);\n  } catch (_a) {\n    return false;\n  }\n}\n\n/**\n * In memory storage like localStorage, but without persistence.\n * Uses as a fallback for localStorage in Safari's private mode.\n */\nclass InMemoryStorage {\n  constructor() {\n    this.storage = {};\n  }\n  static getInstance() {\n    if (!InMemoryStorage.instance) {\n      InMemoryStorage.instance = new InMemoryStorage();\n    }\n    return InMemoryStorage.instance;\n  }\n  get length() {\n    return Object.keys(this.storage).length;\n  }\n  clear() {\n    this.storage = {};\n  }\n  getItem(key) {\n    var _a;\n    return (_a = this.storage[key]) !== null && _a !== void 0 ? _a : null;\n  }\n  key(index) {\n    var _a;\n    const keys = Object.keys(this.storage);\n    if (index < 0 || index >= keys.length) {\n      return null;\n    }\n    return (_a = keys[index]) !== null && _a !== void 0 ? _a : null;\n  }\n  removeItem(key) {\n    delete this.storage[key];\n  }\n  setItem(key, value) {\n    this.storage[key] = value;\n  }\n}\nfunction getWindow() {\n  if (typeof window === 'undefined') {\n    return undefined;\n  }\n  return window;\n}\n/**\n * The function try to get window keys, if it is not available it returns empty array.\n * As an example, for Safari's private mode it returns empty array, because the browser does not allow to get window keys.\n */\nfunction tryGetWindowKeys() {\n  const window = getWindow();\n  if (!window) {\n    return [];\n  }\n  try {\n    return Object.keys(window);\n  } catch (_a) {\n    return [];\n  }\n}\nfunction getDocument() {\n  if (typeof document === 'undefined') {\n    return undefined;\n  }\n  return document;\n}\nfunction getWebPageManifest() {\n  var _a;\n  const origin = (_a = getWindow()) === null || _a === void 0 ? void 0 : _a.location.origin;\n  if (origin) {\n    return origin + '/tonconnect-manifest.json';\n  }\n  return '';\n}\n/**\n * Returns `localStorage` if it is available. In Safari's private mode, it returns `InMemoryStorage`. In Node.js, it throws an error.\n */\nfunction tryGetLocalStorage() {\n  if (isLocalStorageAvailable()) {\n    return localStorage;\n  }\n  if (isNodeJs()) {\n    throw new TonConnectError('`localStorage` is unavailable, but it is required for TonConnect. For more details, see https://github.com/ton-connect/sdk/tree/main/packages/sdk#init-connector');\n  }\n  return InMemoryStorage.getInstance();\n}\n/**\n * Checks if `localStorage` is available.\n */\nfunction isLocalStorageAvailable() {\n  // We use a try/catch block because Safari's private mode throws an error when attempting to access localStorage.\n  try {\n    return typeof localStorage !== 'undefined';\n  } catch (_a) {\n    return false;\n  }\n}\n/**\n * Checks if the environment is Node.js.\n */\nfunction isNodeJs() {\n  return typeof process !== 'undefined' && process.versions != null && process.versions.node != null;\n}\nclass InjectedProvider {\n  constructor(storage, injectedWalletKey) {\n    this.injectedWalletKey = injectedWalletKey;\n    this.type = 'injected';\n    this.unsubscribeCallback = null;\n    this.listenSubscriptions = false;\n    this.listeners = [];\n    const window = InjectedProvider.window;\n    if (!InjectedProvider.isWindowContainsWallet(window, injectedWalletKey)) {\n      throw new WalletNotInjectedError();\n    }\n    this.connectionStorage = new BridgeConnectionStorage(storage);\n    this.injectedWallet = window[injectedWalletKey].tonconnect;\n  }\n  static fromStorage(storage) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const bridgeConnectionStorage = new BridgeConnectionStorage(storage);\n      const connection = yield bridgeConnectionStorage.getInjectedConnection();\n      return new InjectedProvider(storage, connection.jsBridgeKey);\n    });\n  }\n  static isWalletInjected(injectedWalletKey) {\n    return InjectedProvider.isWindowContainsWallet(this.window, injectedWalletKey);\n  }\n  static isInsideWalletBrowser(injectedWalletKey) {\n    if (InjectedProvider.isWindowContainsWallet(this.window, injectedWalletKey)) {\n      return this.window[injectedWalletKey].tonconnect.isWalletBrowser;\n    }\n    return false;\n  }\n  static getCurrentlyInjectedWallets() {\n    if (!this.window) {\n      return [];\n    }\n    const windowKeys = tryGetWindowKeys();\n    const wallets = windowKeys.filter(([_, value]) => isJSBridgeWithMetadata(value));\n    return wallets.map(([jsBridgeKey, wallet]) => ({\n      name: wallet.tonconnect.walletInfo.name,\n      appName: wallet.tonconnect.walletInfo.app_name,\n      aboutUrl: wallet.tonconnect.walletInfo.about_url,\n      imageUrl: wallet.tonconnect.walletInfo.image,\n      tondns: wallet.tonconnect.walletInfo.tondns,\n      jsBridgeKey,\n      injected: true,\n      embedded: wallet.tonconnect.isWalletBrowser,\n      platforms: wallet.tonconnect.walletInfo.platforms\n    }));\n  }\n  static isWindowContainsWallet(window, injectedWalletKey) {\n    return !!window && injectedWalletKey in window && typeof window[injectedWalletKey] === 'object' && 'tonconnect' in window[injectedWalletKey];\n  }\n  connect(message) {\n    this._connect(PROTOCOL_VERSION, message);\n  }\n  restoreConnection() {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        logDebug(`Injected Provider restoring connection...`);\n        const connectEvent = yield this.injectedWallet.restoreConnection();\n        logDebug('Injected Provider restoring connection response', connectEvent);\n        if (connectEvent.event === 'connect') {\n          this.makeSubscriptions();\n          this.listeners.forEach(listener => listener(connectEvent));\n        } else {\n          yield this.connectionStorage.removeConnection();\n        }\n      } catch (e) {\n        yield this.connectionStorage.removeConnection();\n        console.error(e);\n      }\n    });\n  }\n  closeConnection() {\n    if (this.listenSubscriptions) {\n      this.injectedWallet.disconnect();\n    }\n    this.closeAllListeners();\n  }\n  disconnect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return new Promise(resolve => {\n        const onRequestSent = () => {\n          this.closeAllListeners();\n          this.connectionStorage.removeConnection().then(resolve);\n        };\n        try {\n          this.injectedWallet.disconnect();\n          onRequestSent();\n        } catch (e) {\n          logDebug(e);\n          this.sendRequest({\n            method: 'disconnect',\n            params: []\n          }, onRequestSent);\n        }\n      });\n    });\n  }\n  closeAllListeners() {\n    var _a;\n    this.listenSubscriptions = false;\n    this.listeners = [];\n    (_a = this.unsubscribeCallback) === null || _a === void 0 ? void 0 : _a.call(this);\n  }\n  listen(eventsCallback) {\n    this.listeners.push(eventsCallback);\n    return () => this.listeners = this.listeners.filter(listener => listener !== eventsCallback);\n  }\n  sendRequest(request, optionsOrOnRequestSent) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      // TODO: remove deprecated method\n      const options = {};\n      if (typeof optionsOrOnRequestSent === 'function') {\n        options.onRequestSent = optionsOrOnRequestSent;\n      } else {\n        options.onRequestSent = optionsOrOnRequestSent === null || optionsOrOnRequestSent === void 0 ? void 0 : optionsOrOnRequestSent.onRequestSent;\n        options.signal = optionsOrOnRequestSent === null || optionsOrOnRequestSent === void 0 ? void 0 : optionsOrOnRequestSent.signal;\n      }\n      const id = (yield this.connectionStorage.getNextRpcRequestId()).toString();\n      yield this.connectionStorage.increaseNextRpcRequestId();\n      logDebug('Send injected-bridge request:', Object.assign(Object.assign({}, request), {\n        id\n      }));\n      const result = this.injectedWallet.send(Object.assign(Object.assign({}, request), {\n        id\n      }));\n      result.then(response => logDebug('Wallet message received:', response));\n      (_a = options === null || options === void 0 ? void 0 : options.onRequestSent) === null || _a === void 0 ? void 0 : _a.call(options);\n      return result;\n    });\n  }\n  _connect(protocolVersion, message) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        logDebug(`Injected Provider connect request: protocolVersion: ${protocolVersion}, message:`, message);\n        const connectEvent = yield this.injectedWallet.connect(protocolVersion, message);\n        logDebug('Injected Provider connect response:', connectEvent);\n        if (connectEvent.event === 'connect') {\n          yield this.updateSession();\n          this.makeSubscriptions();\n        }\n        this.listeners.forEach(listener => listener(connectEvent));\n      } catch (e) {\n        logDebug('Injected Provider connect error:', e);\n        const connectEventError = {\n          event: 'connect_error',\n          payload: {\n            code: 0,\n            message: e === null || e === void 0 ? void 0 : e.toString()\n          }\n        };\n        this.listeners.forEach(listener => listener(connectEventError));\n      }\n    });\n  }\n  makeSubscriptions() {\n    this.listenSubscriptions = true;\n    this.unsubscribeCallback = this.injectedWallet.listen(e => {\n      logDebug('Wallet message received:', e);\n      if (this.listenSubscriptions) {\n        this.listeners.forEach(listener => listener(e));\n      }\n      if (e.event === 'disconnect') {\n        this.disconnect();\n      }\n    });\n  }\n  updateSession() {\n    return this.connectionStorage.storeConnection({\n      type: 'injected',\n      jsBridgeKey: this.injectedWalletKey,\n      nextRpcRequestId: 0\n    });\n  }\n}\nInjectedProvider.window = getWindow();\n\n/**\n * Default storage to save protocol data, uses `localStorage` if it is available. In Safari's private mode, it uses `InMemoryStorage`. In Node.js, it throws an error.\n */\nclass DefaultStorage {\n  constructor() {\n    this.localStorage = tryGetLocalStorage();\n  }\n  getItem(key) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.localStorage.getItem(key);\n    });\n  }\n  removeItem(key) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.localStorage.removeItem(key);\n    });\n  }\n  setItem(key, value) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.localStorage.setItem(key, value);\n    });\n  }\n}\n\n/**\n * Checks if `WalletInfo` is `WalletInfoInjectable` and `WalletInfo` is injected to the current webpage (`walletInfo.injected === true`).\n * @param value WalletInfo to check.\n */\nfunction isWalletInfoCurrentlyInjected(value) {\n  return isWalletInfoInjectable(value) && value.injected;\n}\n/**\n * Checks if `WalletInfo` is `WalletInfoInjectable` and dApp is opened inside this wallet's browser.\n * @param value WalletInfo to check.\n */\nfunction isWalletInfoCurrentlyEmbedded(value) {\n  return isWalletInfoCurrentlyInjected(value) && value.embedded;\n}\n/**\n * Checks if `WalletInfo` is `WalletInfoInjected`, but doesn't check if it is injected to the page or not.\n * @param value WalletInfo to check.\n */\nfunction isWalletInfoInjectable(value) {\n  return 'jsBridgeKey' in value;\n}\n/**\n * Checks if `WalletInfo` is `WalletInfoRemote`.\n * @param value WalletInfo to check.\n */\nfunction isWalletInfoRemote(value) {\n  return 'bridgeUrl' in value;\n}\n/**\n * @deprecated use `isWalletInfoInjectable` or `isWalletInfoCurrentlyInjected` instead.\n * @param value WalletInfo to check.\n */\nfunction isWalletInfoInjected(value) {\n  return 'jsBridgeKey' in value;\n}\nconst FALLBACK_WALLETS_LIST = [{\n  app_name: 'telegram-wallet',\n  name: 'Wallet',\n  image: 'https://wallet.tg/images/logo-288.png',\n  about_url: 'https://wallet.tg/',\n  universal_url: 'https://t.me/wallet?attach=wallet',\n  bridge: [{\n    type: 'sse',\n    url: 'https://bridge.tonapi.io/bridge'\n  }],\n  platforms: ['ios', 'android', 'macos', 'windows', 'linux']\n}, {\n  app_name: 'tonkeeper',\n  name: 'Tonkeeper',\n  image: 'https://tonkeeper.com/assets/tonconnect-icon.png',\n  tondns: 'tonkeeper.ton',\n  about_url: 'https://tonkeeper.com',\n  universal_url: 'https://app.tonkeeper.com/ton-connect',\n  deepLink: 'tonkeeper-tc://',\n  bridge: [{\n    type: 'sse',\n    url: 'https://bridge.tonapi.io/bridge'\n  }, {\n    type: 'js',\n    key: 'tonkeeper'\n  }],\n  platforms: ['ios', 'android', 'chrome', 'firefox', 'macos']\n}, {\n  app_name: 'mytonwallet',\n  name: 'MyTonWallet',\n  image: 'https://mytonwallet.io/icon-256.png',\n  about_url: 'https://mytonwallet.io',\n  universal_url: 'https://connect.mytonwallet.org',\n  bridge: [{\n    type: 'js',\n    key: 'mytonwallet'\n  }, {\n    type: 'sse',\n    url: 'https://tonconnectbridge.mytonwallet.org/bridge/'\n  }],\n  platforms: ['chrome', 'windows', 'macos', 'linux', 'ios', 'android', 'firefox']\n}, {\n  app_name: 'openmask',\n  name: 'OpenMask',\n  image: 'https://raw.githubusercontent.com/OpenProduct/openmask-extension/main/public/openmask-logo-288.png',\n  about_url: 'https://www.openmask.app/',\n  bridge: [{\n    type: 'js',\n    key: 'openmask'\n  }],\n  platforms: ['chrome']\n}, {\n  app_name: 'tonhub',\n  name: 'Tonhub',\n  image: 'https://tonhub.com/tonconnect_logo.png',\n  about_url: 'https://tonhub.com',\n  universal_url: 'https://tonhub.com/ton-connect',\n  bridge: [{\n    type: 'js',\n    key: 'tonhub'\n  }, {\n    type: 'sse',\n    url: 'https://connect.tonhubapi.com/tonconnect'\n  }],\n  platforms: ['ios', 'android']\n}, {\n  app_name: 'dewallet',\n  name: 'DeWallet',\n  image: 'https://app.delabwallet.com/logo_black.png',\n  about_url: 'https://delabwallet.com',\n  bridge: [{\n    type: 'js',\n    key: 'dewallet'\n  }],\n  platforms: ['chrome']\n}, {\n  app_name: 'xtonwallet',\n  name: 'XTONWallet',\n  image: 'https://xtonwallet.com/assets/img/icon-256-back.png',\n  about_url: 'https://xtonwallet.com',\n  bridge: [{\n    type: 'js',\n    key: 'xtonwallet'\n  }],\n  platforms: ['chrome', 'firefox']\n}, {\n  app_name: 'tonwallet',\n  name: 'TON Wallet',\n  image: 'https://wallet.ton.org/assets/ui/qr-logo.png',\n  about_url: 'https://chrome.google.com/webstore/detail/ton-wallet/nphplpgoakhhjchkkhmiggakijnkhfnd',\n  bridge: [{\n    type: 'js',\n    key: 'tonwallet'\n  }],\n  platforms: ['chrome']\n}];\nclass WalletsListManager {\n  constructor(options) {\n    this.walletsListCache = null;\n    this.walletsListCacheCreationTimestamp = null;\n    this.walletsListSource = 'https://raw.githubusercontent.com/ton-blockchain/wallets-list/main/wallets-v2.json';\n    if (options === null || options === void 0 ? void 0 : options.walletsListSource) {\n      this.walletsListSource = options.walletsListSource;\n    }\n    if (options === null || options === void 0 ? void 0 : options.cacheTTLMs) {\n      this.cacheTTLMs = options.cacheTTLMs;\n    }\n  }\n  getWallets() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.cacheTTLMs && this.walletsListCacheCreationTimestamp && Date.now() > this.walletsListCacheCreationTimestamp + this.cacheTTLMs) {\n        this.walletsListCache = null;\n      }\n      if (!this.walletsListCache) {\n        this.walletsListCache = this.fetchWalletsList();\n        this.walletsListCache.then(() => {\n          this.walletsListCacheCreationTimestamp = Date.now();\n        }).catch(() => {\n          this.walletsListCache = null;\n          this.walletsListCacheCreationTimestamp = null;\n        });\n      }\n      return this.walletsListCache;\n    });\n  }\n  getEmbeddedWallet() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const walletsList = yield this.getWallets();\n      const embeddedWallets = walletsList.filter(isWalletInfoCurrentlyEmbedded);\n      if (embeddedWallets.length !== 1) {\n        return null;\n      }\n      return embeddedWallets[0];\n    });\n  }\n  fetchWalletsList() {\n    return __awaiter(this, void 0, void 0, function* () {\n      let walletsList = [];\n      try {\n        const walletsResponse = yield fetch(this.walletsListSource);\n        walletsList = yield walletsResponse.json();\n        if (!Array.isArray(walletsList)) {\n          throw new FetchWalletsError('Wrong wallets list format, wallets list must be an array.');\n        }\n        const wrongFormatWallets = walletsList.filter(wallet => !this.isCorrectWalletConfigDTO(wallet));\n        if (wrongFormatWallets.length) {\n          logError(`Wallet(s) ${wrongFormatWallets.map(wallet => wallet.name).join(', ')} config format is wrong. They were removed from the wallets list.`);\n          walletsList = walletsList.filter(wallet => this.isCorrectWalletConfigDTO(wallet));\n        }\n      } catch (e) {\n        logError(e);\n        walletsList = FALLBACK_WALLETS_LIST;\n      }\n      let currentlyInjectedWallets = [];\n      try {\n        currentlyInjectedWallets = InjectedProvider.getCurrentlyInjectedWallets();\n      } catch (e) {\n        logError(e);\n      }\n      return this.mergeWalletsLists(this.walletConfigDTOListToWalletConfigList(walletsList), currentlyInjectedWallets);\n    });\n  }\n  walletConfigDTOListToWalletConfigList(walletConfigDTO) {\n    return walletConfigDTO.map(walletConfigDTO => {\n      const walletConfigBase = {\n        name: walletConfigDTO.name,\n        appName: walletConfigDTO.app_name,\n        imageUrl: walletConfigDTO.image,\n        aboutUrl: walletConfigDTO.about_url,\n        tondns: walletConfigDTO.tondns,\n        platforms: walletConfigDTO.platforms\n      };\n      const walletConfig = walletConfigBase;\n      walletConfigDTO.bridge.forEach(bridge => {\n        if (bridge.type === 'sse') {\n          walletConfig.bridgeUrl = bridge.url;\n          walletConfig.universalLink = walletConfigDTO.universal_url;\n          walletConfig.deepLink = walletConfigDTO.deepLink;\n        }\n        if (bridge.type === 'js') {\n          const jsBridgeKey = bridge.key;\n          walletConfig.jsBridgeKey = jsBridgeKey;\n          walletConfig.injected = InjectedProvider.isWalletInjected(jsBridgeKey);\n          walletConfig.embedded = InjectedProvider.isInsideWalletBrowser(jsBridgeKey);\n        }\n      });\n      return walletConfig;\n    });\n  }\n  mergeWalletsLists(list1, list2) {\n    const names = new Set(list1.concat(list2).map(item => item.name));\n    return [...names.values()].map(name => {\n      const list1Item = list1.find(item => item.name === name);\n      const list2Item = list2.find(item => item.name === name);\n      return Object.assign(Object.assign({}, list1Item && Object.assign({}, list1Item)), list2Item && Object.assign({}, list2Item));\n    });\n  }\n  // eslint-disable-next-line complexity\n  isCorrectWalletConfigDTO(value) {\n    if (!value || !(typeof value === 'object')) {\n      return false;\n    }\n    const containsName = 'name' in value;\n    const containsAppName = 'app_name' in value;\n    const containsImage = 'image' in value;\n    const containsAbout = 'about_url' in value;\n    const containsPlatforms = 'platforms' in value;\n    if (!containsName || !containsImage || !containsAbout || !containsPlatforms || !containsAppName) {\n      return false;\n    }\n    if (!value.platforms || !Array.isArray(value.platforms) || !value.platforms.length) {\n      return false;\n    }\n    if (!('bridge' in value) || !Array.isArray(value.bridge) || !value.bridge.length) {\n      return false;\n    }\n    const bridge = value.bridge;\n    if (bridge.some(item => !item || typeof item !== 'object' || !('type' in item))) {\n      return false;\n    }\n    const sseBridge = bridge.find(item => item.type === 'sse');\n    if (sseBridge) {\n      if (!('url' in sseBridge) || !sseBridge.url || !value.universal_url) {\n        return false;\n      }\n    }\n    const jsBridge = bridge.find(item => item.type === 'js');\n    if (jsBridge) {\n      if (!('key' in jsBridge) || !jsBridge.key) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n\n/**\n * Thrown when wallet doesn't support requested feature method.\n */\nclass WalletNotSupportFeatureError extends TonConnectError {\n  get info() {\n    return \"Wallet doesn't support requested feature method.\";\n  }\n  constructor(...args) {\n    super(...args);\n    Object.setPrototypeOf(this, WalletNotSupportFeatureError.prototype);\n  }\n}\nfunction checkSendTransactionSupport(features, options) {\n  const supportsDeprecatedSendTransactionFeature = features.includes('SendTransaction');\n  const sendTransactionFeature = features.find(feature => feature && typeof feature === 'object' && feature.name === 'SendTransaction');\n  if (!supportsDeprecatedSendTransactionFeature && !sendTransactionFeature) {\n    throw new WalletNotSupportFeatureError(\"Wallet doesn't support SendTransaction feature.\");\n  }\n  if (sendTransactionFeature && sendTransactionFeature.maxMessages !== undefined) {\n    if (sendTransactionFeature.maxMessages < options.requiredMessagesNumber) {\n      throw new WalletNotSupportFeatureError(`Wallet is not able to handle such SendTransaction request. Max support messages number is ${sendTransactionFeature.maxMessages}, but ${options.requiredMessagesNumber} is required.`);\n    }\n    return;\n  }\n  logWarning(\"Connected wallet didn't provide information about max allowed messages in the SendTransaction request. Request may be rejected by the wallet.\");\n}\n\n/**\n * Create a request version event.\n */\nfunction createRequestVersionEvent() {\n  return {\n    type: 'request-version'\n  };\n}\n/**\n * Create a response version event.\n * @param version\n */\nfunction createResponseVersionEvent(version) {\n  return {\n    type: 'response-version',\n    version: version\n  };\n}\n/**\n * Create a version info.\n * @param version\n */\nfunction createVersionInfo(version) {\n  return {\n    ton_connect_sdk_lib: version.ton_connect_sdk_lib,\n    ton_connect_ui_lib: version.ton_connect_ui_lib\n  };\n}\nfunction createConnectionInfo(version, wallet) {\n  var _a, _b, _c, _d, _e, _f, _g, _h;\n  const isTonProof = ((_a = wallet === null || wallet === void 0 ? void 0 : wallet.connectItems) === null || _a === void 0 ? void 0 : _a.tonProof) && 'proof' in wallet.connectItems.tonProof;\n  const authType = isTonProof ? 'ton_proof' : 'ton_addr';\n  return {\n    wallet_address: (_c = (_b = wallet === null || wallet === void 0 ? void 0 : wallet.account) === null || _b === void 0 ? void 0 : _b.address) !== null && _c !== void 0 ? _c : null,\n    wallet_type: (_d = wallet === null || wallet === void 0 ? void 0 : wallet.device.appName) !== null && _d !== void 0 ? _d : null,\n    wallet_version: (_e = wallet === null || wallet === void 0 ? void 0 : wallet.device.appVersion) !== null && _e !== void 0 ? _e : null,\n    auth_type: authType,\n    custom_data: Object.assign({\n      chain_id: (_g = (_f = wallet === null || wallet === void 0 ? void 0 : wallet.account) === null || _f === void 0 ? void 0 : _f.chain) !== null && _g !== void 0 ? _g : null,\n      provider: (_h = wallet === null || wallet === void 0 ? void 0 : wallet.provider) !== null && _h !== void 0 ? _h : null\n    }, createVersionInfo(version))\n  };\n}\n/**\n * Create a connection init event.\n */\nfunction createConnectionStartedEvent(version) {\n  return {\n    type: 'connection-started',\n    custom_data: createVersionInfo(version)\n  };\n}\n/**\n * Create a connection completed event.\n * @param version\n * @param wallet\n */\nfunction createConnectionCompletedEvent(version, wallet) {\n  return Object.assign({\n    type: 'connection-completed',\n    is_success: true\n  }, createConnectionInfo(version, wallet));\n}\n/**\n * Create a connection error event.\n * @param version\n * @param error_message\n * @param errorCode\n */\nfunction createConnectionErrorEvent(version, error_message, errorCode) {\n  return {\n    type: 'connection-error',\n    is_success: false,\n    error_message: error_message,\n    error_code: errorCode !== null && errorCode !== void 0 ? errorCode : null,\n    custom_data: createVersionInfo(version)\n  };\n}\n/**\n * Create a connection restoring started event.\n */\nfunction createConnectionRestoringStartedEvent(version) {\n  return {\n    type: 'connection-restoring-started',\n    custom_data: createVersionInfo(version)\n  };\n}\n/**\n * Create a connection restoring completed event.\n * @param version\n * @param wallet\n */\nfunction createConnectionRestoringCompletedEvent(version, wallet) {\n  return Object.assign({\n    type: 'connection-restoring-completed',\n    is_success: true\n  }, createConnectionInfo(version, wallet));\n}\n/**\n * Create a connection restoring error event.\n * @param version\n * @param errorMessage\n */\nfunction createConnectionRestoringErrorEvent(version, errorMessage) {\n  return {\n    type: 'connection-restoring-error',\n    is_success: false,\n    error_message: errorMessage,\n    custom_data: createVersionInfo(version)\n  };\n}\nfunction createTransactionInfo(wallet, transaction) {\n  var _a, _b, _c, _d;\n  return {\n    valid_until: (_a = String(transaction.validUntil)) !== null && _a !== void 0 ? _a : null,\n    from: (_d = (_b = transaction.from) !== null && _b !== void 0 ? _b : (_c = wallet === null || wallet === void 0 ? void 0 : wallet.account) === null || _c === void 0 ? void 0 : _c.address) !== null && _d !== void 0 ? _d : null,\n    messages: transaction.messages.map(message => {\n      var _a, _b;\n      return {\n        address: (_a = message.address) !== null && _a !== void 0 ? _a : null,\n        amount: (_b = message.amount) !== null && _b !== void 0 ? _b : null\n      };\n    })\n  };\n}\n/**\n * Create a transaction init event.\n * @param version\n * @param wallet\n * @param transaction\n */\nfunction createTransactionSentForSignatureEvent(version, wallet, transaction) {\n  return Object.assign(Object.assign({\n    type: 'transaction-sent-for-signature'\n  }, createConnectionInfo(version, wallet)), createTransactionInfo(wallet, transaction));\n}\n/**\n * Create a transaction signed event.\n * @param version\n * @param wallet\n * @param transaction\n * @param signedTransaction\n */\nfunction createTransactionSignedEvent(version, wallet, transaction, signedTransaction) {\n  return Object.assign(Object.assign({\n    type: 'transaction-signed',\n    is_success: true,\n    signed_transaction: signedTransaction.boc\n  }, createConnectionInfo(version, wallet)), createTransactionInfo(wallet, transaction));\n}\n/**\n * Create a transaction error event.\n * @param version\n * @param wallet\n * @param transaction\n * @param errorMessage\n * @param errorCode\n */\nfunction createTransactionSigningFailedEvent(version, wallet, transaction, errorMessage, errorCode) {\n  return Object.assign(Object.assign({\n    type: 'transaction-signing-failed',\n    is_success: false,\n    error_message: errorMessage,\n    error_code: errorCode !== null && errorCode !== void 0 ? errorCode : null\n  }, createConnectionInfo(version, wallet)), createTransactionInfo(wallet, transaction));\n}\n/**\n * Create a disconnect event.\n * @param version\n * @param wallet\n * @param scope\n * @returns\n */\nfunction createDisconnectionEvent(version, wallet, scope) {\n  return Object.assign({\n    type: 'disconnection',\n    scope: scope\n  }, createConnectionInfo(version, wallet));\n}\n\n/**\n * A concrete implementation of EventDispatcher that dispatches events to the browser window.\n */\nclass BrowserEventDispatcher {\n  constructor() {\n    /**\n     * The window object, possibly undefined in a server environment.\n     * @private\n     */\n    this.window = getWindow();\n  }\n  /**\n   * Dispatches an event with the given name and details to the browser window.\n   * @param eventName - The name of the event to dispatch.\n   * @param eventDetails - The details of the event to dispatch.\n   * @returns A promise that resolves when the event has been dispatched.\n   */\n  dispatchEvent(eventName, eventDetails) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      const event = new CustomEvent(eventName, {\n        detail: eventDetails\n      });\n      (_a = this.window) === null || _a === void 0 ? void 0 : _a.dispatchEvent(event);\n    });\n  }\n  /**\n   * Adds an event listener to the browser window.\n   * @param eventName - The name of the event to listen for.\n   * @param listener - The listener to add.\n   * @param options - The options for the listener.\n   * @returns A function that removes the listener.\n   */\n  addEventListener(eventName, listener, options) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      (_a = this.window) === null || _a === void 0 ? void 0 : _a.addEventListener(eventName, listener, options);\n      return () => {\n        var _a;\n        return (_a = this.window) === null || _a === void 0 ? void 0 : _a.removeEventListener(eventName, listener);\n      };\n    });\n  }\n}\n\n/**\n * Tracker for TonConnect user actions, such as transaction signing, connection, etc.\n *\n * List of events:\n *  * `connection-started`: when a user starts connecting a wallet.\n *  * `connection-completed`: when a user successfully connected a wallet.\n *  * `connection-error`: when a user cancels a connection or there is an error during the connection process.\n *  * `connection-restoring-started`: when the dApp starts restoring a connection.\n *  * `connection-restoring-completed`: when the dApp successfully restores a connection.\n *  * `connection-restoring-error`: when the dApp fails to restore a connection.\n *  * `disconnection`: when a user starts disconnecting a wallet.\n *  * `transaction-sent-for-signature`: when a user sends a transaction for signature.\n *  * `transaction-signed`: when a user successfully signs a transaction.\n *  * `transaction-signing-failed`: when a user cancels transaction signing or there is an error during the signing process.\n *\n * If you want to track user actions, you can subscribe to the window events with prefix `ton-connect-`:\n *\n * @example\n * window.addEventListener('ton-connect-transaction-sent-for-signature', (event) => {\n *    console.log('Transaction init', event.detail);\n * });\n *\n * @internal\n */\nclass TonConnectTracker {\n  constructor(options) {\n    var _a;\n    /**\n     * Event prefix for user actions.\n     * @private\n     */\n    this.eventPrefix = 'ton-connect-';\n    /**\n     * TonConnect UI version.\n     */\n    this.tonConnectUiVersion = null;\n    this.eventDispatcher = (_a = options === null || options === void 0 ? void 0 : options.eventDispatcher) !== null && _a !== void 0 ? _a : new BrowserEventDispatcher();\n    this.tonConnectSdkVersion = options.tonConnectSdkVersion;\n    this.init().catch();\n  }\n  /**\n   * Version of the library.\n   */\n  get version() {\n    return createVersionInfo({\n      ton_connect_sdk_lib: this.tonConnectSdkVersion,\n      ton_connect_ui_lib: this.tonConnectUiVersion\n    });\n  }\n  /**\n   * Called once when the tracker is created and request version other libraries.\n   */\n  init() {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield this.setRequestVersionHandler();\n        this.tonConnectUiVersion = yield this.requestTonConnectUiVersion();\n      } catch (e) {}\n    });\n  }\n  /**\n   * Set request version handler.\n   * @private\n   */\n  setRequestVersionHandler() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.eventDispatcher.addEventListener('ton-connect-request-version', () => __awaiter(this, void 0, void 0, function* () {\n        yield this.eventDispatcher.dispatchEvent('ton-connect-response-version', createResponseVersionEvent(this.tonConnectSdkVersion));\n      }));\n    });\n  }\n  /**\n   * Request TonConnect UI version.\n   * @private\n   */\n  requestTonConnectUiVersion() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n        try {\n          yield this.eventDispatcher.addEventListener('ton-connect-ui-response-version', event => {\n            resolve(event.detail.version);\n          }, {\n            once: true\n          });\n          yield this.eventDispatcher.dispatchEvent('ton-connect-ui-request-version', createRequestVersionEvent());\n        } catch (e) {\n          reject(e);\n        }\n      }));\n    });\n  }\n  /**\n   * Emit user action event to the window.\n   * @param eventDetails\n   * @private\n   */\n  dispatchUserActionEvent(eventDetails) {\n    try {\n      this.eventDispatcher.dispatchEvent(`${this.eventPrefix}${eventDetails.type}`, eventDetails).catch();\n    } catch (e) {}\n  }\n  /**\n   * Track connection init event.\n   * @param args\n   */\n  trackConnectionStarted(...args) {\n    try {\n      const event = createConnectionStartedEvent(this.version, ...args);\n      this.dispatchUserActionEvent(event);\n    } catch (e) {}\n  }\n  /**\n   * Track connection success event.\n   * @param args\n   */\n  trackConnectionCompleted(...args) {\n    try {\n      const event = createConnectionCompletedEvent(this.version, ...args);\n      this.dispatchUserActionEvent(event);\n    } catch (e) {}\n  }\n  /**\n   * Track connection error event.\n   * @param args\n   */\n  trackConnectionError(...args) {\n    try {\n      const event = createConnectionErrorEvent(this.version, ...args);\n      this.dispatchUserActionEvent(event);\n    } catch (e) {}\n  }\n  /**\n   * Track connection restoring init event.\n   * @param args\n   */\n  trackConnectionRestoringStarted(...args) {\n    try {\n      const event = createConnectionRestoringStartedEvent(this.version, ...args);\n      this.dispatchUserActionEvent(event);\n    } catch (e) {}\n  }\n  /**\n   * Track connection restoring success event.\n   * @param args\n   */\n  trackConnectionRestoringCompleted(...args) {\n    try {\n      const event = createConnectionRestoringCompletedEvent(this.version, ...args);\n      this.dispatchUserActionEvent(event);\n    } catch (e) {}\n  }\n  /**\n   * Track connection restoring error event.\n   * @param args\n   */\n  trackConnectionRestoringError(...args) {\n    try {\n      const event = createConnectionRestoringErrorEvent(this.version, ...args);\n      this.dispatchUserActionEvent(event);\n    } catch (e) {}\n  }\n  /**\n   * Track disconnect event.\n   * @param args\n   */\n  trackDisconnection(...args) {\n    try {\n      const event = createDisconnectionEvent(this.version, ...args);\n      this.dispatchUserActionEvent(event);\n    } catch (e) {}\n  }\n  /**\n   * Track transaction init event.\n   * @param args\n   */\n  trackTransactionSentForSignature(...args) {\n    try {\n      const event = createTransactionSentForSignatureEvent(this.version, ...args);\n      this.dispatchUserActionEvent(event);\n    } catch (e) {}\n  }\n  /**\n   * Track transaction signed event.\n   * @param args\n   */\n  trackTransactionSigned(...args) {\n    try {\n      const event = createTransactionSignedEvent(this.version, ...args);\n      this.dispatchUserActionEvent(event);\n    } catch (e) {}\n  }\n  /**\n   * Track transaction error event.\n   * @param args\n   */\n  trackTransactionSigningFailed(...args) {\n    try {\n      const event = createTransactionSigningFailedEvent(this.version, ...args);\n      this.dispatchUserActionEvent(event);\n    } catch (e) {}\n  }\n}\nconst tonConnectSdkVersion = \"3.0.3\";\nclass TonConnect {\n  constructor(options) {\n    this.walletsList = new WalletsListManager();\n    this._wallet = null;\n    this.provider = null;\n    this.statusChangeSubscriptions = [];\n    this.statusChangeErrorSubscriptions = [];\n    this.dappSettings = {\n      manifestUrl: (options === null || options === void 0 ? void 0 : options.manifestUrl) || getWebPageManifest(),\n      storage: (options === null || options === void 0 ? void 0 : options.storage) || new DefaultStorage()\n    };\n    this.walletsList = new WalletsListManager({\n      walletsListSource: options === null || options === void 0 ? void 0 : options.walletsListSource,\n      cacheTTLMs: options === null || options === void 0 ? void 0 : options.walletsListCacheTTLMs\n    });\n    this.tracker = new TonConnectTracker({\n      eventDispatcher: options === null || options === void 0 ? void 0 : options.eventDispatcher,\n      tonConnectSdkVersion: tonConnectSdkVersion\n    });\n    if (!this.dappSettings.manifestUrl) {\n      throw new DappMetadataError('Dapp tonconnect-manifest.json must be specified if window.location.origin is undefined. See more https://github.com/ton-connect/docs/blob/main/requests-responses.md#app-manifest');\n    }\n    this.bridgeConnectionStorage = new BridgeConnectionStorage(this.dappSettings.storage);\n    if (!(options === null || options === void 0 ? void 0 : options.disableAutoPauseConnection)) {\n      this.addWindowFocusAndBlurSubscriptions();\n    }\n  }\n  /**\n   * Returns available wallets list.\n   */\n  static getWallets() {\n    return this.walletsList.getWallets();\n  }\n  /**\n   * Shows if the wallet is connected right now.\n   */\n  get connected() {\n    return this._wallet !== null;\n  }\n  /**\n   * Current connected account or null if no account is connected.\n   */\n  get account() {\n    var _a;\n    return ((_a = this._wallet) === null || _a === void 0 ? void 0 : _a.account) || null;\n  }\n  /**\n   * Current connected wallet or null if no account is connected.\n   */\n  get wallet() {\n    return this._wallet;\n  }\n  set wallet(value) {\n    this._wallet = value;\n    this.statusChangeSubscriptions.forEach(callback => callback(this._wallet));\n  }\n  /**\n   * Returns available wallets list.\n   */\n  getWallets() {\n    return this.walletsList.getWallets();\n  }\n  /**\n   * Allows to subscribe to connection status changes and handle connection errors.\n   * @param callback will be called after connections status changes with actual wallet or null.\n   * @param errorsHandler (optional) will be called with some instance of TonConnectError when connect error is received.\n   * @returns unsubscribe callback.\n   */\n  onStatusChange(callback, errorsHandler) {\n    this.statusChangeSubscriptions.push(callback);\n    if (errorsHandler) {\n      this.statusChangeErrorSubscriptions.push(errorsHandler);\n    }\n    return () => {\n      this.statusChangeSubscriptions = this.statusChangeSubscriptions.filter(item => item !== callback);\n      if (errorsHandler) {\n        this.statusChangeErrorSubscriptions = this.statusChangeErrorSubscriptions.filter(item => item !== errorsHandler);\n      }\n    };\n  }\n  connect(wallet, requestOrOptions) {\n    var _a, _b;\n    // TODO: remove deprecated method\n    const options = {};\n    if (typeof requestOrOptions === 'object' && 'tonProof' in requestOrOptions) {\n      options.request = requestOrOptions;\n    }\n    if (typeof requestOrOptions === 'object' && ('openingDeadlineMS' in requestOrOptions || 'signal' in requestOrOptions || 'request' in requestOrOptions)) {\n      options.request = requestOrOptions === null || requestOrOptions === void 0 ? void 0 : requestOrOptions.request;\n      options.openingDeadlineMS = requestOrOptions === null || requestOrOptions === void 0 ? void 0 : requestOrOptions.openingDeadlineMS;\n      options.signal = requestOrOptions === null || requestOrOptions === void 0 ? void 0 : requestOrOptions.signal;\n    }\n    if (this.connected) {\n      throw new WalletAlreadyConnectedError();\n    }\n    const abortController = createAbortController(options === null || options === void 0 ? void 0 : options.signal);\n    (_a = this.abortController) === null || _a === void 0 ? void 0 : _a.abort();\n    this.abortController = abortController;\n    if (abortController.signal.aborted) {\n      throw new TonConnectError('Connection was aborted');\n    }\n    (_b = this.provider) === null || _b === void 0 ? void 0 : _b.closeConnection();\n    this.provider = this.createProvider(wallet);\n    abortController.signal.addEventListener('abort', () => {\n      var _a;\n      (_a = this.provider) === null || _a === void 0 ? void 0 : _a.closeConnection();\n      this.provider = null;\n    });\n    this.tracker.trackConnectionStarted();\n    return this.provider.connect(this.createConnectRequest(options === null || options === void 0 ? void 0 : options.request), {\n      openingDeadlineMS: options === null || options === void 0 ? void 0 : options.openingDeadlineMS,\n      signal: abortController.signal\n    });\n  }\n  /**\n   * Try to restore existing session and reconnect to the corresponding wallet. Call it immediately when your app is loaded.\n   */\n  restoreConnection(options) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      this.tracker.trackConnectionRestoringStarted();\n      const abortController = createAbortController(options === null || options === void 0 ? void 0 : options.signal);\n      (_a = this.abortController) === null || _a === void 0 ? void 0 : _a.abort();\n      this.abortController = abortController;\n      if (abortController.signal.aborted) {\n        this.tracker.trackConnectionRestoringError('Connection restoring was aborted');\n        return;\n      }\n      // TODO: potentially race condition here\n      const [bridgeConnectionType, embeddedWallet] = yield Promise.all([this.bridgeConnectionStorage.storedConnectionType(), this.walletsList.getEmbeddedWallet()]);\n      if (abortController.signal.aborted) {\n        this.tracker.trackConnectionRestoringError('Connection restoring was aborted');\n        return;\n      }\n      let provider = null;\n      try {\n        switch (bridgeConnectionType) {\n          case 'http':\n            provider = yield BridgeProvider.fromStorage(this.dappSettings.storage);\n            break;\n          case 'injected':\n            provider = yield InjectedProvider.fromStorage(this.dappSettings.storage);\n            break;\n          default:\n            if (embeddedWallet) {\n              provider = this.createProvider(embeddedWallet);\n            } else {\n              return;\n            }\n        }\n      } catch (_c) {\n        this.tracker.trackConnectionRestoringError('Provider is not restored');\n        yield this.bridgeConnectionStorage.removeConnection();\n        provider === null || provider === void 0 ? void 0 : provider.closeConnection();\n        provider = null;\n        return;\n      }\n      if (abortController.signal.aborted) {\n        provider === null || provider === void 0 ? void 0 : provider.closeConnection();\n        this.tracker.trackConnectionRestoringError('Connection restoring was aborted');\n        return;\n      }\n      if (!provider) {\n        logError('Provider is not restored');\n        this.tracker.trackConnectionRestoringError('Provider is not restored');\n        return;\n      }\n      (_b = this.provider) === null || _b === void 0 ? void 0 : _b.closeConnection();\n      this.provider = provider;\n      provider.listen(this.walletEventsListener.bind(this));\n      const onAbortRestore = () => {\n        this.tracker.trackConnectionRestoringError('Connection restoring was aborted');\n        provider === null || provider === void 0 ? void 0 : provider.closeConnection();\n        provider = null;\n      };\n      abortController.signal.addEventListener('abort', onAbortRestore);\n      return yield callForSuccess(_options => __awaiter(this, void 0, void 0, function* () {\n        yield provider === null || provider === void 0 ? void 0 : provider.restoreConnection({\n          openingDeadlineMS: options === null || options === void 0 ? void 0 : options.openingDeadlineMS,\n          signal: _options.signal\n        });\n        abortController.signal.removeEventListener('abort', onAbortRestore);\n        if (this.connected) {\n          this.tracker.trackConnectionRestoringCompleted(this.wallet);\n        } else {\n          this.tracker.trackConnectionRestoringError('Connection restoring failed');\n        }\n      }), {\n        attempts: Number.MAX_SAFE_INTEGER,\n        delayMs: 5000,\n        signal: options === null || options === void 0 ? void 0 : options.signal\n      });\n    });\n  }\n  sendTransaction(transaction, optionsOrOnRequestSent) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // TODO: remove deprecated method\n      const options = {};\n      if (typeof optionsOrOnRequestSent === 'function') {\n        options.onRequestSent = optionsOrOnRequestSent;\n      } else {\n        options.onRequestSent = optionsOrOnRequestSent === null || optionsOrOnRequestSent === void 0 ? void 0 : optionsOrOnRequestSent.onRequestSent;\n        options.signal = optionsOrOnRequestSent === null || optionsOrOnRequestSent === void 0 ? void 0 : optionsOrOnRequestSent.signal;\n      }\n      const abortController = createAbortController(options === null || options === void 0 ? void 0 : options.signal);\n      if (abortController.signal.aborted) {\n        throw new TonConnectError('Transaction sending was aborted');\n      }\n      this.checkConnection();\n      checkSendTransactionSupport(this.wallet.device.features, {\n        requiredMessagesNumber: transaction.messages.length\n      });\n      this.tracker.trackTransactionSentForSignature(this.wallet, transaction);\n      const {\n          validUntil\n        } = transaction,\n        tx = __rest(transaction, [\"validUntil\"]);\n      const from = transaction.from || this.account.address;\n      const network = transaction.network || this.account.chain;\n      const response = yield this.provider.sendRequest(sendTransactionParser.convertToRpcRequest(Object.assign(Object.assign({}, tx), {\n        valid_until: validUntil,\n        from,\n        network\n      })), {\n        onRequestSent: options.onRequestSent,\n        signal: abortController.signal\n      });\n      if (sendTransactionParser.isError(response)) {\n        this.tracker.trackTransactionSigningFailed(this.wallet, transaction, response.error.message, response.error.code);\n        return sendTransactionParser.parseAndThrowError(response);\n      }\n      const result = sendTransactionParser.convertFromRpcResponse(response);\n      this.tracker.trackTransactionSigned(this.wallet, transaction, result);\n      return result;\n    });\n  }\n  /**\n   * Disconnect form thw connected wallet and drop current session.\n   */\n  disconnect(options) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.connected) {\n        throw new WalletNotConnectedError();\n      }\n      const abortController = createAbortController(options === null || options === void 0 ? void 0 : options.signal);\n      const prevAbortController = this.abortController;\n      this.abortController = abortController;\n      if (abortController.signal.aborted) {\n        throw new TonConnectError('Disconnect was aborted');\n      }\n      this.onWalletDisconnected('dapp');\n      yield (_a = this.provider) === null || _a === void 0 ? void 0 : _a.disconnect({\n        signal: abortController.signal\n      });\n      prevAbortController === null || prevAbortController === void 0 ? void 0 : prevAbortController.abort();\n    });\n  }\n  /**\n   * Pause bridge HTTP connection. Might be helpful, if you want to pause connections while browser tab is unfocused,\n   * or if you use SDK with NodeJS and want to save server resources.\n   */\n  pauseConnection() {\n    var _a;\n    if (((_a = this.provider) === null || _a === void 0 ? void 0 : _a.type) !== 'http') {\n      return;\n    }\n    this.provider.pause();\n  }\n  /**\n   * Unpause bridge HTTP connection if it is paused.\n   */\n  unPauseConnection() {\n    var _a;\n    if (((_a = this.provider) === null || _a === void 0 ? void 0 : _a.type) !== 'http') {\n      return Promise.resolve();\n    }\n    return this.provider.unPause();\n  }\n  addWindowFocusAndBlurSubscriptions() {\n    const document = getDocument();\n    if (!document) {\n      return;\n    }\n    try {\n      document.addEventListener('visibilitychange', () => {\n        if (document.hidden) {\n          this.pauseConnection();\n        } else {\n          this.unPauseConnection().catch();\n        }\n      });\n    } catch (e) {\n      logError('Cannot subscribe to the document.visibilitychange: ', e);\n    }\n  }\n  createProvider(wallet) {\n    let provider;\n    if (!Array.isArray(wallet) && isWalletConnectionSourceJS(wallet)) {\n      provider = new InjectedProvider(this.dappSettings.storage, wallet.jsBridgeKey);\n    } else {\n      provider = new BridgeProvider(this.dappSettings.storage, wallet);\n    }\n    provider.listen(this.walletEventsListener.bind(this));\n    return provider;\n  }\n  walletEventsListener(e) {\n    switch (e.event) {\n      case 'connect':\n        this.onWalletConnected(e.payload);\n        break;\n      case 'connect_error':\n        this.onWalletConnectError(e.payload);\n        break;\n      case 'disconnect':\n        this.onWalletDisconnected('wallet');\n    }\n  }\n  onWalletConnected(connectEvent) {\n    const tonAccountItem = connectEvent.items.find(item => item.name === 'ton_addr');\n    const tonProofItem = connectEvent.items.find(item => item.name === 'ton_proof');\n    if (!tonAccountItem) {\n      throw new TonConnectError('ton_addr connection item was not found');\n    }\n    const wallet = {\n      device: connectEvent.device,\n      provider: this.provider.type,\n      account: {\n        address: tonAccountItem.address,\n        chain: tonAccountItem.network,\n        walletStateInit: tonAccountItem.walletStateInit,\n        publicKey: tonAccountItem.publicKey\n      }\n    };\n    if (tonProofItem) {\n      wallet.connectItems = {\n        tonProof: tonProofItem\n      };\n    }\n    this.wallet = wallet;\n    this.tracker.trackConnectionCompleted(wallet);\n  }\n  onWalletConnectError(connectEventError) {\n    const error = connectErrorsParser.parseError(connectEventError);\n    this.statusChangeErrorSubscriptions.forEach(errorsHandler => errorsHandler(error));\n    logDebug(error);\n    this.tracker.trackConnectionError(connectEventError.message, connectEventError.code);\n    if (error instanceof ManifestNotFoundError || error instanceof ManifestContentErrorError) {\n      logError(error);\n      throw error;\n    }\n  }\n  onWalletDisconnected(scope) {\n    this.tracker.trackDisconnection(this.wallet, scope);\n    this.wallet = null;\n  }\n  checkConnection() {\n    if (!this.connected) {\n      throw new WalletNotConnectedError();\n    }\n  }\n  createConnectRequest(request) {\n    const items = [{\n      name: 'ton_addr'\n    }];\n    if (request === null || request === void 0 ? void 0 : request.tonProof) {\n      items.push({\n        name: 'ton_proof',\n        payload: request.tonProof\n      });\n    }\n    return {\n      manifestUrl: this.dappSettings.manifestUrl,\n      items\n    };\n  }\n}\nTonConnect.walletsList = new WalletsListManager();\n/**\n * Check if specified wallet is injected and available to use with the app.\n * @param walletJSKey target wallet's js bridge key.\n */\nTonConnect.isWalletInjected = walletJSKey => InjectedProvider.isWalletInjected(walletJSKey);\n/**\n * Check if the app is opened inside specified wallet's browser.\n * @param walletJSKey target wallet's js bridge key.\n */\nTonConnect.isInsideWalletBrowser = walletJSKey => InjectedProvider.isInsideWalletBrowser(walletJSKey);\nconst noBounceableTag = 0x51;\nconst testOnlyTag = 0x80;\n/**\n * Converts raw TON address to no-bounceable user-friendly format. [See details]{@link https://ton.org/docs/learn/overviews/addresses#user-friendly-address}\n * @param hexAddress raw TON address formatted as \"0:<hex string without 0x>\".\n * @param [testOnly=false] convert address to test-only form. [See details]{@link https://ton.org/docs/learn/overviews/addresses#user-friendly-address}\n */\nfunction toUserFriendlyAddress(hexAddress, testOnly = false) {\n  const {\n    wc,\n    hex\n  } = parseHexAddress(hexAddress);\n  let tag = noBounceableTag;\n  if (testOnly) {\n    tag |= testOnlyTag;\n  }\n  const addr = new Int8Array(34);\n  addr[0] = tag;\n  addr[1] = wc;\n  addr.set(hex, 2);\n  const addressWithChecksum = new Uint8Array(36);\n  addressWithChecksum.set(addr);\n  addressWithChecksum.set(crc16(addr), 34);\n  let addressBase64 = Base64.encode(addressWithChecksum);\n  return addressBase64.replace(/\\+/g, '-').replace(/\\//g, '_');\n}\nfunction parseHexAddress(hexAddress) {\n  if (!hexAddress.includes(':')) {\n    throw new WrongAddressError(`Wrong address ${hexAddress}. Address must include \":\".`);\n  }\n  const parts = hexAddress.split(':');\n  if (parts.length !== 2) {\n    throw new WrongAddressError(`Wrong address ${hexAddress}. Address must include \":\" only once.`);\n  }\n  const wc = parseInt(parts[0]);\n  if (wc !== 0 && wc !== -1) {\n    throw new WrongAddressError(`Wrong address ${hexAddress}. WC must be eq 0 or -1, but ${wc} received.`);\n  }\n  const hex = parts[1];\n  if ((hex === null || hex === void 0 ? void 0 : hex.length) !== 64) {\n    throw new WrongAddressError(`Wrong address ${hexAddress}. Hex part must be 64bytes length, but ${hex === null || hex === void 0 ? void 0 : hex.length} received.`);\n  }\n  return {\n    wc,\n    hex: hexToBytes(hex)\n  };\n}\nfunction crc16(data) {\n  const poly = 0x1021;\n  let reg = 0;\n  const message = new Uint8Array(data.length + 2);\n  message.set(data);\n  for (let byte of message) {\n    let mask = 0x80;\n    while (mask > 0) {\n      reg <<= 1;\n      if (byte & mask) {\n        reg += 1;\n      }\n      mask >>= 1;\n      if (reg > 0xffff) {\n        reg &= 0xffff;\n        reg ^= poly;\n      }\n    }\n  }\n  return new Uint8Array([Math.floor(reg / 256), reg % 256]);\n}\nconst toByteMap = {};\nfor (let ord = 0; ord <= 0xff; ord++) {\n  let s = ord.toString(16);\n  if (s.length < 2) {\n    s = '0' + s;\n  }\n  toByteMap[s] = ord;\n}\nfunction hexToBytes(hex) {\n  hex = hex.toLowerCase();\n  const length2 = hex.length;\n  if (length2 % 2 !== 0) {\n    throw new ParseHexError('Hex string must have length a multiple of 2: ' + hex);\n  }\n  const length = length2 / 2;\n  const result = new Uint8Array(length);\n  for (let i = 0; i < length; i++) {\n    const doubled = i * 2;\n    const hexSubstring = hex.substring(doubled, doubled + 2);\n    if (!toByteMap.hasOwnProperty(hexSubstring)) {\n      throw new ParseHexError('Invalid hex character: ' + hexSubstring);\n    }\n    result[i] = toByteMap[hexSubstring];\n  }\n  return result;\n}\nexport { BadRequestError, BrowserEventDispatcher, FetchWalletsError, LocalstorageNotFoundError, ParseHexError, TonConnect, TonConnectError, UnknownAppError, UnknownError, UserRejectsError, WalletAlreadyConnectedError, WalletNotConnectedError, WalletNotInjectedError, WalletsListManager, WrongAddressError, createConnectionCompletedEvent, createConnectionErrorEvent, createConnectionRestoringCompletedEvent, createConnectionRestoringErrorEvent, createConnectionRestoringStartedEvent, createConnectionStartedEvent, createDisconnectionEvent, createRequestVersionEvent, createResponseVersionEvent, createTransactionSentForSignatureEvent, createTransactionSignedEvent, createTransactionSigningFailedEvent, createVersionInfo, TonConnect as default, encodeTelegramUrlParameters, isTelegramUrl, isWalletInfoCurrentlyEmbedded, isWalletInfoCurrentlyInjected, isWalletInfoInjectable, isWalletInfoInjected, isWalletInfoRemote, toUserFriendlyAddress };","map":null,"metadata":{},"sourceType":"module"}